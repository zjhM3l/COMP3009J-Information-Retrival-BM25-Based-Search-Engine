NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- A Survey of Elliptic Curve Cryptosystems, Part I: Introductory San C. Vo NASA Advanced Supercomputing (NAS) Division Research Branch (INR) Information Sciences 
An elliptic curve is a two-dimensional (planar) curve defined by an equation involving a cubic power of coordinate x and a square power of coordinate y.
One class of these curves is elliptic curves over finite fields, also called Galois fields.
These elliptic curves are finite groups with special structures, which can play naturally, and even more flexibly, the roles of the modulus groups in the discrete logarithm problems.
Elliptic curves have been used actively in designing many mathematical, computational and cryptographic algorithms, such as integer factoring, primality proving, public key cryptosystems and pseudo-random number generators, etc.
Essentially, elliptic curve cryptosystems promise a better future for cryptography: more security against powerful attacks in the era of computing capability.
Many research papers in Elliptic Curve Cryptography (ECC) have been published by researchers all over the world.
However, the idea of using elliptic curves in cryptography is still considered a difficult concept and is neither widely accepted nor understood by typical technical people.
The problem may stem from the fact that there is a large gap between the theoretical mathematics of elliptic curves and the applications of elliptic curves in cryptography.
A large amount of ECC literature was collected and organized in the development of this survey on ECC. Part I (Introductory) of this survey gives a modest overview of how elliptic curves have been applied to public key cryptography.
The objective is to introduce a bridge between the mathematical facts of elliptic curves and its application for cryptography.
The document attempts to provide clear, intuitive and elementary explanations to guide a typical technical reader into the world of elliptic curve cryptography.
However, basic knowledge of cryptography and abstract algebra, including group theory and number theory, would be helpful for readers in several technical areas.
Part II of this survey, that will be developed, intends to focus more on practical implementations.
The materials cover elliptic curves and their basic mathematical rules, the Elliptic Curve Discrete Logarithm Problem (ECDLP) and many typical attacks on ECDLP-based cryptosystems.
Also included are descriptions of elliptic curve public key cryptosystems or schemes (encryption/decryption, digital signature, key agreement and key transport schemes).
The document concludes with discussions of elliptic curve implementations, the security and advantages of ECC.
It is hoped that this survey could provide readers good initial background on the path into the new and exciting area of elliptic curve cryptography, that is attracting more attention from cryptographers, computer scientists and researchers all over the world.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 1 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Notations 
Elliptic Curves over Finite Fields A. Finite fields 1.
Basic facts 2.
Prime and binary finite fields B.
The curve and the group C. Order of the group over finite fields 1.
Hasse's theorem 2.
Formulae and algorithms on elliptic curve group orders 3.
Supersingularity 4.
Structure of the group 5.
Schoof's algorithm and improvements Chapter 2.
Elliptic Curve Cryptosystems 15 A. Introduction to elliptic curve cryptosystems 1.
The discrete logarithm problem 2.
The cryptographic problems on elliptic curves 3.
Approaches in elliptic curve cryptosystems 4.
Public key and private key generation B. Message encryption/decryption schemes 1.
Elliptic curve analogue of the ElGamal cryptosystem 2.
Massey-Omura elliptic curve cryptosystem 3.
Menezes-Vanstone elliptic curve cryptosystem C. Digital signature 
Elliptic curve digital signature schemes 2.
Elliptic curve digital signature schemes with message recovery 3.
Summary of digital signature schemes 4.
Signcryption schemes 5.
Schnorr's authentication schemes D. Key agreement 
Elliptic curve Diffie-Hellman key agreement 2.
Elliptic curve MTI key agreement 3.
Elliptic curve Menezes-Qu-Vanstone key agreement (MQV) E. RSA-type elliptic curve cryptosystems 1.
Public key cryptosystems using elliptic curves over a ring ZN 2.
RSA-type elliptic curve cryptosystems 3.
Elliptic curve digital signature 
Attacks on Elliptic Curve Cryptosystems 34 A. Running time of algorithms B. Algorithms on the discrete logarithm problem C. Algorithms on the elliptic curve discrete logarithm problem D. Application of Weil pairing and MOV reduction attack E. SSA attack (Smart-Satoh-Araki attack) ______________________________________________________________________ __________________ Contents Page 03 05 A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 2 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- F. Chapter 4.
A. B. C. Appendices A. B. C. References Differential and power attacks Implementations of Elliptic Curve Cryptosystems 43 Implementations of finite fields 1.
Finite fields 2.
Polynomial bases 3.
Normal bases and optimal normal bases 4.
Optimal normal basis (ONB) 5.
Low-complexity normal bases for GF(2m) (or Gaussian normal bases) 6.
Self-dual bases and self-dual normal bases 7.
Primitive normal bases 8.
Non-conventional basis 9.
The choice of bases 10.
Comparisons of finite fields 11.
Composite extension finite fields and subfields 12.
Optimal extension fields (OEF) Implementations of elliptic curves 1.
Conditions for selecting appropriate elliptic curves 2.
Methods of constructing elliptic curves 3.
Finding a point of a given prime order on an elliptic curve 4.
Methods/formulae to compute the order of an elliptic curve 5.
Schoof's and Satoh's algorithm for point-counting Implementations of elliptic curve arithmetic operations 1.
Scalar point multiplication: basic methods 2.
Scalar point multiplication: advanced methods 3.
Scalar point multiplication: other methods 4.
Algorithms on composite extension finite fields 5.
Representing points on an elliptic curve 6.
Half-point algorithms 7.
Modular multiplication algorithm 81 Trace functions 1.
Trace of a finite field element 2.
Properties on order of an elliptic curve 3.
Trace of an elliptic curve Twisted curves Examples 90 Notations 
Notation Meaning Notation Meaning Fq or GF(q) Finite field of order q (x + iy) = Real part of a complex ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 3 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Fp or GF(p) Fq* = Fq\{0} GF(q)* = GF(q) \{0} F2 m or (consisting of q elements) Prime finite field of order p (consisting of p elements) Multiplicative subgroup of the finite field Fq or GF(q) Binary finite field of order 2m (consisting of 2m elements) Elliptic curve E over finite field Fq or GF(q) Order of an elliptic curve E over finite field Fq or GF(q) Order of a finite field Fq or GF(q) Twisted curve of E Group generated by an element P or g An elliptic curve point represented with its x- and y-coordinates Discriminant The point at infinity of an elliptic curve Legendre symbol (modulo a prime number p) Jacobi symbol (b is composite number) Ring of integers modulo N, where N is composite Table i. Meaning Anomalous binary curve or binary anomalous curve Advanced encryption standard Complex Multiplication Data Encryption Standard Diffie-Hellman algorithm Diffie-Hellman problem ( z) = x (x + iy) = ( z) = y aÃ¯Â¿Â½P, (aÃ¯Â¿Â½P), aP or (aP) a|b ab Tr(Ã¯Â¿Â½) Z Q R [a, b]
Since 1985, two mathematicians Miller and Koblitz have been considered the cofounders of elliptic curve cryptography.
It is a new branch in cryptography that uses an old, interesting and difficult topic in mathematics or, particularly, algebra: elliptic curves over finite fields.
This has both fortunate and "unfortunate" consequences for elliptic curve cryptography.
It is fortunate because ECC is based on a strong fundamental mathematical background.
This makes the solution of the Elliptic Curve Discrete Logarithm Problem still infeasible; hence it still serves as the security core of elliptic curve cryptosystems.
The "unfortunate" aspect is that the background of ECC is too complicated to be explained elementarily.
The theory of RSA (Rivest-Shamir-Adleman) cryptosystems, which are based on the Integer Factoring Problem, is fortunately rather easy to discuss using high-school mathematics.
The cryptosystems, which are based on the Discrete Logarithm Problem defined on a finite field, require only elementary number theory knowledge about modular multiplications and additions.
To understand the theory of ECC, the reader must study elliptic curves and get familiar with basic mathematical concepts related to elliptic curves.
1.A.
Finite fields 1.A.1.
Basic facts ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 5 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Here, we state briefly, without proof, basic facts on finite fields, necessary for further discussion on the subject.
For more details, please refer to books on the theory of finite fields.
Finite fields, also called Galois fields, are fields consisting of a finite number of elements.
A finite field has pm elements where p is a prime number and m is a natural number.
We call pm the order of the finite field.
There is no finite field of order n, if n is not a positive power of a prime number.
For any prime p and positive integer m, there always exists a Galois field of order m p.
Two finite fields of the same number of elements pm are isomorphic, or roughly speaking, they are the same finite field.
We then call it the Galois field (or finite field) of order pm, which is denoted by either GF(pm) or F m . p We call p the characteristic of the finite field GF(pm).
In general, the characteristic of a field F is the smallest positive integer p such that pÃ¯Â¿Â½1 = 14241 = 0, where 1 is the +3 1L+ p terms multiplicative identity of the field.
We write char(F) = p.
Then the arithmetic operations over a finite field are reduced simply to multiplications and additions modulo p.
It can be shown that p must be a prime number, because otherwise we can find a prime factor p1 of p, (hence p1 
The contradiction on the minimum of prime p proves the claim.
A cyclic group G is a group that can be generated from any one of its elements.
For multiplicative cyclic group G (whose operation is a multiplication Ã¯Â¿Â½) and any given element g in G, there is an element a in G and a positive number k such that: ak = a a K3 = g.
For an additive cyclic group (whose operation is an addition +) and any 1 4a 42 k terms given element g in G, there is an element a in G and a positive number k such that: ka = a + 4+ L 4a = g. a + 14243 k terms The multiplicative subgroup of a finite field Fq, written as consisting of non-zero elements, or invertible elements of a finite field cyclic of order (q 1).
Particularly, we have: aq1 = 1, a Fq*.
1.A.2.
Prime and binary finite fields Let Fq be the Galois finite field of q elements, where q = pm for positive integer m. When m = 1, we usually denote the finite field Fp by Z/pZ or Z Fq* = Fq\{0} is Fq.
This group is some prime p and p (if there will be no confusion with the p-adic field).
The arithmetic operations on Fp are the usual addition and multiplication modulo p.
When m 2, then we have: Fp m Z p m .
In fact, Z p m is only a ring, and it is even / not a field, let alone Galois field, since, for instance, any element that is a multiple of p is equal to 0, not 1; hence it has no inverse.
From now on, we will consider only elliptic curves E(Fq) defined over finite field Fq, where q = pm and char(Fq) = p. Particularly, there are two cases: ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 6 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- If p is a prime characteristic char(Fp) operations are addition If p = 2, then q and its characteristic is char (GF(2m)) = 2.
It is called a binary finite field.
The simplest case of a finite field is when m = 1.
The finite field F2 = {0,1} has the following operations: 0+0=1+1=0 0Ã¯Â¿Â½0 = 0Ã¯Â¿Â½1 = 1Ã¯Â¿Â½0 = 0 1+0=0+1=1 1Ã¯Â¿Â½1 = 1.
We consider a less obvious case m = 2: the finite field GF(22).
Let 3 = 1 and 1.
The elements of GF(22) are 0, 1, and 2 = + 1.
Using the standard trinomial basis, we can write: GF(22) = {(00) = 0, (01) = 1, (10) = , (11) = 2}.
Simple operations on GF(22) are: + = 2 + 2 = 1 + 1 = 0 + 2 = 1 1 + 2 = 2 2 Ã¯Â¿Â½ = Ã¯Â¿Â½ = 1 2Ã¯Â¿Â½2 = The curve and the group Let E be an elliptic curve over a finite field Fq whose equation is given as follows.
Over prime finite field Fp where prime p 2, 3, we use elliptic curves of equation y2 = x3 + ax + b, where = 16(4a3 + 27b2) 0.
Over binary finite field GF(2m), we use non-supersingular elliptic curves of equation: y2 + xy = x3 + ax2 + b , where = b 0.
We will also discuss supersingular elliptic curves over binary finite field GF(2m) whose equations are of the form: y2 + cy = x3 + ax + b, where = c4 0.
All the points of E(Fq), including the point at infinity, (which is denoted conveniently as O), form an abelian (or commutative) group whose identity element is O and the group law is addition +, which is defined as follows.
We will then consider E as both a curve and a group simultaneously.
This group of elliptic curve points is the group on which an elliptic curve cryptosystem will be defined.
It is similar to the case of DiffieHellman cryptosystem, (Diffie 
Additive inverse of a point P First, we have O = O.
For any point P = (x, y) O on E, the additive inverse point (P) of point P is defined as in the table 1.1.
P = (x, y) Equation of elliptic curve E over a finite field Fq 2 3 P = (x, y) y = x + ax + b (over Fp where prime p 2, 3) 2 3 2 m y + xy = x + ax + b (non-supersingular elliptic curve over GF(2 )) P = (x, y + x) y2 + cy = x3 + ax + b (supersingular elliptic curve over GF(2m)) P = (x, y + c) Point addition rules For any point P O and Q O on E, we have P + Q = Q + P = R, where the inverse point ( R) is the intersection point of the elliptic y -(A+B) curve E with the line going through P and Q if P Q or with tangent line at D o o number 
In this case, the finite field is Fp and its = p 
Particularly, Fp = {0, 1, 2,..., (p 1)} whose field and multiplication modulo p.
It is called a prime finite field.
= 2m for some positive integer m.
The finite field is GF(2m) or F2m 1.B.
2D B o o ______________________________________________________________________ __________________ o D A A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 -2D o o x Page 7 of 105 C=A+B NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- the tangent line to the elliptic curve at the point P if P = Q.
(There is exactly one such point of intersection ( R), since the intersection of a straight line and a cubic curve will give at most 3 points.)
The addition rules, which are also called chord-and-tangent laws, will be best illustrated with the field of real numbers R as in the graph in Figure 1.1.
Figure 1.1.
Point addition rules (or chord-and-tangent rules) for an elliptic curve However, for finite fields, an elliptic curve is not a continuous curve, but it is a collection of scattered points and the point at infinity O (which is not drawn).
Refer to Figure 1.2 and 1.3.
For example, let us consider the elliptic curve E: y2 = x3 + x + 6 over the finite field F11, which has order #E(F11) = 13.
E= P={(2,7), (5,2), (8,3), (10,2), (3,6), (7,9), (7,2), (3,5), (10,9), (8,8), (5,9), (2,4), O}. y 10 9 8 7 6 5 4 3 2 1 0 0 1 2 3 o P o o oB A o o 2P 45 6 o o A +B 7 8 o x Addition (2,4) + (3,5) = (7,2) or 12P+8P = 20P = 7P -(A+B) Doubling o o 2.(2,7) =(5,2) o Figure 1.2.
The graph of an elliptic curve E((GF11)): y2 = x3 + x + 6 includes 12 points and the point at infinity O.
The number of points is #E((GF11)) = 13.
The point addition rules over finite field GF11.
9 10 y Figure 1.3.
The graph of an elliptic curve 13 points and the point at The number of points is 1o 6 5 4 o o o o oo o o o 3 E(GF(23)): y2 = x3 + x + 1 has infinity O. #E(GF(23)) = 14.
x 2 1 0 0 1 2 3 4 5 6 1 o oo We have, trivially, P + (P) = O.
One can imagine that the third intersection point of the elliptic curve and the line going through 2 points P and (P) is at infinity.
Hence O is called the point at infinity.
The explicit formulae for the addition of two non-identity points P = (x1, y1) and Q = (x2, y2) in all three cases discussed above are given in table 1.2.
There is a basic property of cubic equations that was used in deriving those formulae.
If x1, x2 and x3 are three roots of a cubic equation X3 + aX2 + bX + c = 0, then x1 + x2 + x3 = a.
Point doubling formula When P = Q, the addition formula is called the formula for doubling a point P.
This is the basic arithmetic for scalar point multiplication that will be used the most in implementations of elliptic curves.
Scalar multiplication of a point (or Scalar point mutiplication) Given a point P on an elliptic curve E and an integer k, the scalar point multiplication of P by k is the point kÃ¯Â¿Â½P that is computed by the following formula: kÃ¯Â¿Â½P = 1+ 4+ L 4P if k 
P 4 24+3 P k terms ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 8 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- The notation kÃ¯Â¿Â½P is usually replaced where the context is clear.
Obviously, we have: 0Ã¯Â¿Â½P = P Equation of elliptic curve E over a finite field Fq Over Fp where prime p 2, 3 y2 = x3 + ax + b, = 16(4a3 + 27b2) 0 P = (x1, y1) Q = (x2, y2) by other equally popular notations: kP, (kP) or (kÃ¯Â¿Â½P) + ( P) = O. R = (x3, y3) = (x1, y1) + (x2, y2) where Non-supersingular elliptic curve over GF(2m) y2 + xy = x3 + ax2 + b, b 0 P = (x1, y1) Q = (x2, y2) Let = y1 + y2 y and Ã¯Â¿Â½ = x1 + 1 .
x1 + x2 x1 x3 = 2 x1 x2 y3 = (x1 x3) y1 y 2 - y1 x - x if P Ã¯Â¿Â½ Q 2 1 where = 2 3x1 + a if P = Q. 2 y1 If y1 = 0, then P = (x1, 0) = P. Hence 2.P = O. y + y 2 y + y 2 2 1 + x1 + x2 + a + 1 x1 + x2 x1 + x2 = 2 + + x1 + x2 + a x3 = if P Ã¯Â¿Â½ Q b x12+ 2 = Ã¯Â¿Â½ 2 + Ã¯Â¿Â½ + a if P = Q, x1 y1 + y2 ( x1 + x3 ) + x3 + y1 x1 + x2 = .( x1 + x3 ) + x3 + y1 if P Ã¯Â¿Â½ Q y3 = x 2+ x + y1 . x + x 3 1 1 x1 3 = x12+( Ã¯Â¿Â½ + 1).
x3 if P = Q.
If x1 = 0, then P = (0, b ) = P. Hence 2P = O. y + y 2 2 1 + x1 + x2 x1 + x2 x3 = = 2 + x1 + x2 4 2 x1 + a = 2 c2 y1 + y2 ( x1 + x3 ) + y1 x1 + x2 = .( x1 + x3 ) + y3 = 2 x1 + a c ( x1 + x3 ) + y1 = .( x1 + x3 ) + Supersingular elliptic curve over GF(2m) y2 + cy = x3 + ax + b, c0 P = ( x1 , y1 ) Q = ( x2 , y2 ) Let = y1 + y2 x2 + a and = 1 x1 + x2 c if P Ã¯Â¿Â½ Q if P = Q, +c y1 + c +c y1 + c if P = Q. Page 9 of 105 if P Ã¯Â¿Â½ Q ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Table 1.2.
Point addition formulae for elliptic curves over finite fields The order n of a point P is the smallest positive integer such that nÃ¯Â¿Â½P = O.
In fact, the graph of an elliptic curve over a finite field consists of a finite number of points (together with the point at infinity).
It is not a continuous curve as in the case where an elliptic curve is defined over real numbers.
But we still have a similar property: a line going through any two points will pass through one and only one other point.
1.C.
Order of the group over finite fields 1.C.1.
Hasse's theorem The order of the group E(Fq) is #E(Fq) = q + 1 t, where | t | 2 q1/2.
By this theorem, the order of an elliptic curve is roughly about the order of the finite field.
For any element a Fq, if it is the x-coordinate of a point P in E(Fq), then it is also the x-coordinate of the point (P).
Hence, the probability for a Fq to be the xcoordinate of a point in E(Fq) is roughly equal to Ã¯Â¿Â½.
This theorem is commonly called the Riemann Hypothesis for elliptic curves over a finite field.
It was proved, for many of its cases, by Artin in his Ph.D. thesis, for elliptic curves by Hasse, and for curves of higher genus.
Note that this is not the same as the Riemann Hypothesis for the Riemann zeta function.
Property: In general, any value | t | 2p1/2 can occur if gcd (t, p) =1, for any characteristic p. Particularly: When q = p, a prime, every possible value of t (i.e., | t | 2p1/2) can be attained by some elliptic curve.
When | t | p1/2, the elliptic curves are roughly equally distributed.
When q is even (or p = 2), every odd value of t such that | t | 2q1/2 can be attained by some non-supersingular elliptic curve.
Waterhouse's lemma ([W69]): For q = pm, there exists an elliptic curve E over a finite field Fq such that the elliptic curve order #E(Fq) = q + 1 t, if and only if one of the following conditions holds: (i) t 0 (mod p) and t2 4q. (ii) m is odd and one of the followings holds: (1) t = 0.
(2) t2 = pq = pm+1 if p = 2 or 3.
(iii) m is even and one of the followings holds: (1) t2 = 4q.
(2) t2 = q and p 1 (mod 3).
(3) t = 0 and p 1 (mod 4).
1.C.2.
Formulae and algorithms on elliptic curve group orders Hasse-Weil's theorem (Weil's conjecture, proved by Helmut Hasse in 1934.)
Let E be an elliptic curve over a finite field Fq.
Then E is also an elliptic curve over an extension field GF(qk) of Fq.
As a group, we have the inclusion relationship: E(Fq) E(GF(qk)).
That is, the elliptic curve order #E(Fq) must divide the elliptic curve order # E(GF(qk)).
Moreover, if #E(Fq) = q + 1 t, then # E(GF(qk)) = qk + 1 k k, where and are complex numbers satisfying the equation: qT2 tT + 1 = (1 T) (1 T).
This theorem helps to compute the order of an elliptic curve defined over a composite extension finite field from the order of the same elliptic curve over one of its ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 10 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- subfields.
Explicitly, we have two relationships between elements and : + = t and = q. Then the order #E(GF(qk)) can be computed via the sum Sk = k + k that is given by the following recursive formula (also called a Lucas sequence): Sk = ( + )Sk 1 Sk 2 = t Sk 1 q Sk 2 , for k 2, where S0 = 2 and S1 = + = t. Direct formulae for the orders of elliptic curves over finite fields When the finite field is of computationally small order, one still can use direct formulae to find the order of an elliptic curve.
For each and every element x Fq, we will determine whether there is (are) 0, 1 or 2 corresponding values of y by the Legendre symbol (in prime finite field Fp) and the trace function (in binary finite field GF(2m)).
Summary of results is in the table 1.3.
Equation of elliptic Order of the elliptic curve curve E over a finite #E(Fq) field Fq Over Fp, p 2, 3 x 3 + ax + b x 3 + ax + b 2 3 , + 1 = p + 1 #E = 1 + y = x + ax + b p p xF p xF p 3 2 = 16(4a + 27b ) where * denotes the Legendre symbol.
0 p () -2 Non-supersingular #E = 2 + 1 + (-1)Tr ( a + x + b. x ) elliptic curve over 0 xF m 2 GF(2m) -2 m = 2 + 1 + (1)Tr(a) (-1)Tr ( x + b.x ) y2 + xy = x3 + ax2 + b 0 xGF ( 2 m ) b0 When x = 0, we always have one solution: y = b1/2 = b The order must be an even number.
-2 3 Supersingular elliptic #E = 1 + 1 + (-1)Tr [ c ( x + ax + b )] m curve over GF(2 ) xGF ( 2 m ) 2 3 -2 3 -2 y + cy = x + ax + b = 2m + 1 + (-1)Tr ( c b ) (-1)Tr [ c ( x + ax )]
( ) The order must be an odd number of possible values: #E = 2m + 1, 2m + 1 Ã¯Â¿Â½ 2m/2, 2m + 1 Ã¯Â¿Â½ 2(m+1)/2, or 2m + 1 Ã¯Â¿Â½ 2(m+2)/2.
Table 1.3.
Direct formulae for computing the orders of elliptic curves over finite fields Other algorithms Many particular elliptic curves over particular finite fields, whose the orders are easily computed or formulated, are implemented in cryptography for different purposes.
For examples, the Koblitz curves or elliptic curves over a prime finite field Fp of the form Ep(a,0): y2 = x3 + ax, for a 0 (mod p) or Ep(0,b): y2 = x3 + b, for b 0 (mod p).
For a general elliptic curve over larger finite field Fq, one should use Shanks' Baby-step-Giant-step algorithm (Buchmann 
The idea is to pick up a random point P on the elliptic curve and to compute an integer n such that: q + 1 2q1/2 n q + 1 + 2q1/2 and nP = O.
If we can find only one such number, then it is the order of the elliptic curve.
If not, we find another point and continue.
The groups, generated by all the points that we picked, will eventually have the order of the elliptic curve.
Its running time is about O(q1/4).
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 11 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Shanks' Baby-step-Giant-step algorithm can fail when multiple values of n are available for every point P. Mestre [M86] showed that if Shanks' algorithm fails for an elliptic curve, then it will not fail on its twisted curve.
If an elliptic curve has Complex Multiplication properties, there are other efficient algorithms to count the points.
Refer to Lenstra 
In 1985, Schoof's algorithm, which is of polynomial running time, was proposed and later has been improved both theoretically and practically to be used to compute the order of an elliptic curve over very large finite fields.
1.C.3.
Supersingularity An elliptic curve over a finite field Fq, where q = pm, is supersingular if p divides t, where #E(Fq) = q + 1 t.
If otherwise, it is a non-supersingular elliptic curve.
Lemma (i) If char(Fq) = 2 (or 3), the elliptic curve E(Fq) is supersingular if and only if its j-invariant is equal to 0.
(ii) The elliptic curve E(Fq) is supersingular if and only if either t2 = 0, q, 2q, 3q or 4q.
From the lemma, we observe that: If q is even (i.e., q = 2m), then E is nonsupersingular, when #E(GF(2m)) is even or t is odd.
Otherwise, if E is supersingular, when t is even, or the order #E(GF(2m)) is odd.
Explicitly, the possible values of #E(GF(2m)) for supersingular elliptic curves are: 2m + 1, 2m + 1 Ã¯Â¿Â½ 2m/2, 2m + 1 Ã¯Â¿Â½ 2(m+1)/2 and 2m + 1 Ã¯Â¿Â½ 2(m+2)/2.
Each value can be attained provided it is an integer, of course.
If q = p, a prime 
Indeed, the simple reason is that | t | 2p1/2 
Hence the condition p|t implies that t = 0.
The class of supersingular elliptic curves also is an interesting area of research in cryptography.
The supersingular elliptic curves over either finite fields Fp or GF(2m) are vulnerable to the MOV attack (Menezes, Okamoto 
We now re-state Waterhouse's lemma in a different way, taking consideration of supersingularity [BS91].
Lemma: There exists an elliptic curve E over a finite field Fq where q = pm, such that #E(Fq) = q + 1 t, if and only if one of the following conditions holds: (i) For the case of supersingular curves, m is even: t = Ã¯Â¿Â½2q1/2 = Ã¯Â¿Â½ 2pm/2. m is even and p 1 (mod 3): t = Ã¯Â¿Â½q1/2 = Ã¯Â¿Â½ pm/2. m is odd and p = 2 or 3: t = Ã¯Â¿Â½ (pq)/12 = Ã¯Â¿Â½ p(m+1)/2. m is odd or m is even and p 1 (mod 4): t = 0.
(ii) For the case of non-supersingular curves, two conditions | t | 2q1/2 and gcd (t, p) = 1 must hold.
1.C.4.
Structure of the group The group E(Fq) is either a cyclic group or a direct sum of two cyclic groups Z n Z n , where n2|n1 and n2|(q 1).
That is, we have n2| gcd(n1, q 1).
1 2 The elliptic curve has order # E(Fq) = n1n2.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 12 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- This result together with the theory of abelian groups can help us determine the group structure.
One effective technique in algebra is counting the number of points of particular order.
There are many special cases to consider.
In an easiest case, the order of a point to be considered is 2.
In fact, points of order 2 are of the form (x, 0) when char(Fq) 2, 3.
For non-supersingular elliptic curves when char(Fq) = 2, there is only one point of order 2.
It is (0, 1/2).
Lemma: If the order #E(Fq) is square-free, then E(Fq) is a cyclic group.
In other words, if any prime number s such that s2|#E(Fq) must satisfy the condition s(q 1), then the group E(Fq) is cyclic.
1.C.5.
Schoof's algorithm and improvements This is a short historical summary of developments of the Schoof's algorithm since its original version in 1985.
Many developed steps of the complete algorithm are described in more details in the cited references.
a.
Schoof ([S85],[S87]
It originally applied in the case where q = pm and p 
Schoof used the theory of division polynomials and Frobenius endomorphisms to determine the order N (modulo l) for a collection of small primes l.
If the number of such primes is large enough, such that the product of such primes l 
Schoof's algorithm is a deterministic method.
This algorithm has a running time of about O(ln8 q) or O(ln9 q).
Buchmann 
First, we compute the order #E(Fq) mod (l1l2...ls) for a few small primes l1, l2,..., ls, using Schoof's algorithm.
This helps to reduce the table size in the Baby-step-Giant-step algorithm by a factor of the inverse product (l1 l2...ls) 1.
Menezes, Vanstone 
b.
Since Schoof's algorithm's running time is too slow, it was not practical in applied cryptography.
Later, improvements in both theory and implementation were made by Elkies and Atkin in their unpublished manuscripts from 1986 to 1992.
Atkin and Elkies used the properties of modular polynomials to get the possible values of N modulo l.
This method introduced new concepts: Atkin primes and Elkies primes.
It involves the isogeny between two l-isogenous elliptic curves.
Atkin and Elkies also proposed using more modular equations and modular forms to improve the implementation.
The improvements have provided more efficient implementation of Schoof's algorithm over finite fields of any large characteristic.
The improved Schoof's algorithm is then called Schoof-Elkies-Atkin (SEA) algorithm.
Implementations of this algorithm were presented in a few works, such as Morain [Mo95] and Joux 
Couveignes 
Lehmann, Maurer, MÃ¯Â¿Â½ller 
More details were also organized in Schoof [S95].
The author also discussed Mestre's method and Cornacchia's algorithm.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 13 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Mestre's method is to simplify to Shanks' Baby-step-Giant-step algorithm in the special cases.
This method is practical for finite fields that are not too large.
Cornacchia's algorithm uses the natural lattice structure of the endomorphism ring of the elliptic curve and then it is very effective if the ring is known.
It is the basis for the primality test by Atkin 
The problem remains for the case p = 2, or in fact, for small characteristics less Couveignes [C94] proposed a method to then l, the prime degree of isogenies.
work for any p, hence, helped to solve the case p = 2, using the formal group associated to an elliptic curve.
It is an important theoretical breakthrough that speeds up the computations significantly.
The first successful implementation of this algorithm was presented in Lercier 
Its running time is of O(l3) elementary field operations and need a memory storage of O(l2).
The main cost for a counting algorithm in this case is the computation of isogenies of prime degree l between two isogenous elliptic curves.
d. Later, Lercier [L96] proposed a heuristic algorithm for computing the isogenies, for the case of characteristic 2, to replace that method in Couveignes' algorithm since this is too slow and requires too much memory.
Lercier's method works on the elliptic curve itself instead of on its formal group.
Its running time is also O(l3) field operations, but it is faster by a significant constant factor in practice and conceptually simpler.
The memory space required is reduced to only O(l).
It is not known whether this method can be generalized to the case of any other characteristic.
In turn, Couveignes proposed a general algorithm (method II) using elementary Galois properties of the p-torsion points, without using the formal group.
It works for any characteristic.
It was based on the ideas in Lercier 
This algorithm allows the use of fast multiplication for polynomials to achieve its running time at O(l2+) field operations.
This method seems to reduce significantly the burden of implementation of a point counting algorithm.
The memory required is also O(l). e. References on current developments of the algorithm are discussed in Couveignes [C96], Couveignes, Dewaghe 
Some surveys are helpful to understand the general ideas: Buchmann, MÃ¯Â¿Â½ller 
Satoh's method is based on the canonical p-adic lift of an ordinary elliptic curve.
Fouquet, Gaudry 
The authors also showed in [FGH01] an implementation of the Satoh-FGH algorithm and an early-abort strategy based on the Schoof-Elkies-Atkin (SEA) algorithm to find secure random elliptic curves in finite fields of characteristic 2 in a faster time than previous methods.
Chapter 2 Elliptic Curve Cryptosystems ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 14 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- We will discuss basic cryptosystems using elliptic curves, such as encryption/decryption, digital signatures and key agreement, etc.
For each scheme, we provide brief discussions and analyses on their security against some known attacks that are already published.
We also mention RSA-type elliptic curve cryptosystems that have interesting applications.
2.A.
Introduction to elliptic curve cryptosystems 2.A.1.
The discrete logarithm problem The discrete logarithm problem can be defined over any abelian group.
For simplicity, we recall the definition of DLP over finite cyclic group.
Let G be a finite cyclic group of order n and generated by g, i.e., G = g. Given a point y G, find an integer m, 0 m n 1, such that y = gm.
We call m = logg y the discrete logarithm of y to the base element g.
The DLP can be solved in a sub-exponential running time.
In cryptography, one usually takes group G as the cyclic (multiplicative) subgroup of a modulo group Zp where p is a prime number.
Then G = Zp* = Zp\ {0} and its order is |G| = |Zp*| = p 1.
Let g be a generator of G.
Then given y G = g = Zp*, the DLP is to find an integer m, 0 m p 1, such that y = gm (mod p).
More generally, group G can be the multiplicative group in a finite field GF(pm) Then its order is n = |G| = |GF(pm)*| = pm 1.
In fact, for cryptographic security reasons, one prefers to work on a cyclic subgroup of G whose order is a prime number that divides the number (pm 1).
A variety of groups are used in this problem instead of the modulo groups.
Now we will consider using the group of points on an elliptic curve over finite fields.
2.A.2.
The cryptographic problems on elliptic curves a.
The elliptic curve discrete logarithm problem Given a point P of order n in an elliptic curve E over a finite field Fq and a point Q in the subgroup of E generated by P, denoted by P, the ECDLP is to find an integer m, where 0 m n 1, such that Q = mÃ¯Â¿Â½P.
Another way to describe the problem is: Given a point P of order n in an elliptic curve E over a finite field Fq and a point Q in E, the ECDLP is to find an integer m, 0 m n 1, such that Q = mÃ¯Â¿Â½P if such a number exists.
Point P is called the base point in this problem.
We call m = logPQ the elliptic curve discrete logarithm of Q to the base point P.
The ECDLP is believed to be unsolvable in sub-exponential time, while there are already algorithms to solve the DLP in sub-exponential time.
The following lemma from group theory tells us whether a solution for an ECDLP exists.
Lemma: Let N be the order of the elliptic curve E and n be the order of the subgroup P (generated by point P).
Let l = N/n be the cofactor, or the index, of subgroup P.
If gcd(n, l) = 1, then a point Q in the elliptic curve E is in subgroup P if and only if nÃ¯Â¿Â½Q = O. ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 15 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- The condition gcd(n, l) = 1 is easily satisfied, since in practice, n should be a prime number.
b. Elliptic curve Diffie-Hellman problem Elliptic curve Diffie-Hellman problem (ECDHP) ([DH76]): Given a point P of order n in an elliptic curve E over a finite field Fq and two points (kÃ¯Â¿Â½P) and (lÃ¯Â¿Â½P),the ECDHP is to find the point (klÃ¯Â¿Â½P).
This problem is also used in the elliptic curve Diffie-Hellman key exchange algorithm.
Boneh 
Elliptic curve decision Diffie-Hellman problem (ECDDHP) (Boneh [B98]): Given a point P of order n in an elliptic curve E over a finite field Fq and three points (kÃ¯Â¿Â½P), (lÃ¯Â¿Â½P) and (mÃ¯Â¿Â½P), the ECDDHP is to decide whether m = kl (modulo the order of point P).
The ECDDHP is not harder than the ECDHP.
Boneh 
2.A.3.
Approaches in elliptic curve cryptosystems In 1985, Koblitz and Miller independently introduced the use of the group of points of an elliptic curve over a finite field in cryptosystems based on the elliptic curve discrete logarithm problem.
(Koblitz' work [K87] was not published until two years later than Miller's [Mi85]
They are called elliptic curve cryptosystems.
In the current cryptography literature, there are basically three approaches.
(i) Diffie-Hellman/DSA-type elliptic curve cryptosystems Many proposed elliptic curve cryptosystems of this type are mentioned, such as ElGamal, Menezes-Vanstone, Massey-Omura, Schnorr, Nyberg-Rueppel schemes, MQV schemes.
They are also used in many Standards such as ANSI X9.62 
(iii) Other elliptic curve cryptosystems: using supersingular elliptic curves or Koblitz curves.
A Koblitz curve over GF(2m) is a non-supersingular elliptic curve whose defining function has coefficients in F2.
In literature, they are also referred as anomalous binary curves (ABC's) or binary anomalous curves.
These curves must have the form Ea: y2 + xy = x3 + ax2 + 1, where a = 0 or 1.
These curves are non-supersingular elliptic curves (in order to resist MOV attack) and not vulnerable to the SSA attack.
They are easy to create and implementbecause of Complex Mulitplication properties.
We will present the outline of practical approaches of elliptic curve cryptosystems that are proposed in cryptography literature.
They are grouped into: message encryption/decryption schemes, digital signature schemes with and without message recovery, authentication schemes, key exchange and key agreement schemes, RSA-type elliptic curve cryptosystems, and elliptic curve digital signature schemes over a ring ZN.
Each scheme or cryptosystem will be presented in its basic algorithms.
Simple analyses on security that should be widely known in literature and a few typical features will be also pointed out where possible.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 16 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- 2.A.4.
Public key and private key generation Let E be a non-supersingular elliptic curve defined over the finite field Fq, where either q = 2m, for some positive integer m or q is a prime greater than 3.
Choose P as a base point of a big prime order n in E(Fq).
We will work on the group generated by the point P: P = {O, P, 2P,..., (n 1)P}.
Key generation: The signer will select a random integer d in the interval [2, n 2], and compute the point Q = dÃ¯Â¿Â½P.
The private key is d and public key is Q or, in fact, a pair of points P and Q on the elliptic curve.
Message encryption/decryption schemes Unless stated otherwise, the elliptic curve E is a non-supersingular curve defined over a (Galois) finite field Fq, where q is a prime p 
Simple analyses on security and specification features are occasionally discussed.
2.B.1.
Elliptic curve analogue of the ElGamal cryptosystem ([E85]) A point P of order n on an elliptic curve E is fixed and publicly known.
User A chooses a random number d, keeps it secretly, and publishes the key Q = dÃ¯Â¿Â½P.
To send a message m to user A, user B first embeds m to a point M = (mx, my) on E, then chooses a random integer k. User B will send a pair of points (kÃ¯Â¿Â½P, M + kÃ¯Â¿Â½Q), assuming kÃ¯Â¿Â½Q O.
To decrypt the message, user A will use his secret key to compute: M = (M + kQ) d(kP).
A disadvantage of this cryptosystem is that one must use a point M = (mx, my) on the elliptic curve to embed the message m. Hence it limits the plaintext space somehow.
This is another drawback, since the eavesdropper can recover the full message if he somehow knows only one part of it, either mx or my.
An alternative version of this cryptosystem is to replace the elliptic curve addition in (M + kQ) by a regular finite field addition in both encryption and decryption.
This avoids the above disadvantage; now message M is not necessarily embedded on the elliptic curve.
Encryption: Assuming that kQ (0,0), then the ciphertext is the pair of data that includes: M (kQ) = (mx + (kQ)x, my + (kQ)y) and point (kP).
Here the addition + is the regular finite field addition.
Decryption: Using his secret key a, user A can recover the plaintext as: [M (kQ)] d(kP) = (mx + (kQ)x (kQ)x, my + (kQ)y (kQ)y) = (mx, my) = M.
In this algorithm, one does not need to compute the order of the elliptic curve.
But in practice, we need to do so for security confidence on the infeasibility of the ECDLP.
The ciphertext is expanded by a factor of 2 (or only 3/2 if one uses compressing techniques).
The same drawback: if someone knows mx (or my), he can solve for (kQ)x then (kQ)y and my (or mx) easily.
Another version of this scheme is just to use the x-coordinate of a point, and hence the message M is now just written as M = mx.
Then the message will be XOR-ed with (kQ)x and concatenated with kÃ¯Â¿Â½P to form the ciphertext: kQ || M (kQ)x.
The decryption is similar to the method described above, after (kÃ¯Â¿Â½P) is extracted from the ciphertext.
2.B.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 17 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Alternative version using symmetric key encryption: The message will be encrypted by a symmetric key encryption scheme SKE with (kÃ¯Â¿Â½Q) as a secret key and will be sent together with (kÃ¯Â¿Â½P) to user A. User A receives the ciphertext, the pair e = SKE(kQ)(M) and point (kÃ¯Â¿Â½P).
User A then uses his secret key a to compute aÃ¯Â¿Â½ (kÃ¯Â¿Â½P) = kÃ¯Â¿Â½Q and uses (kÃ¯Â¿Â½Q) to decrypt the message: M = SKE(-k1.Q ) (e).
2.B.2.
Massey-Omura elliptic curve cryptosystem ([MO86]) This cryptosystem will be used to send a message m that is embedded as a point P on a fixed elliptic curve whose order N is computed and also publicly known.
Each user will choose at random an integer e such that gcd(e, N) = 1, and compute d such that e.d 1 (mod N).
Both e and d are kept secret.
That is, for some integer k, (ed)Ã¯Â¿Â½P = (1 + kN) Ã¯Â¿Â½P = P + kNÃ¯Â¿Â½P = P + O = P. User A sends eAP to user B.
Then user B sends back eB(eAP) to user A.
Then user A does his decryption by computing: dA.(eB(eAP) = eB.P and sends it back to user B.
No one can read the message yet, up to this stage.
Finally, user B does his decryption to read the message: dB(eBP) = P.
The security of this cryptosystem is obviously based on the infeasibility of ECDLP.
Massey-Omura elliptic curve cryptosystem can be considered a variant version of the original Diffie-Hellman key exchange scheme.
2.B.3.
Menezes-Vanstone elliptic curve cryptosystem ([MV90],[MV93]
Let E be a non-supersingular elliptic curve defined over a finite field Fp, where prime p 
Choose a point P in E(Fp) of order n and compute the point Q = dÃ¯Â¿Â½P with the secret key d.
The pair (P, Q) are public keys.
Encryption: The sender will choose a secret random number k in the interval [1, n 1].
The ciphertext of a message m = (m1, m2) Zp*Ã¯Â¿Â½Zp* will be the triple including the point k.P and two finite field elements y1 and y2 where y1 = c1m1 (mod p) and y2 = c2m2 (mod p), and assuming kQ = (c1, c2) (0,0).
Decryption: The receiver uses his secret key d to compute the point dÃ¯Â¿Â½(kÃ¯Â¿Â½P) that should be exactly kQ = (c1, c2).
Hence the receiver can recover the message by: - ( y1c1-1 (mod p), y 2 c2 1 (mod p)) = (m1, m2).
Analysis: There is also a message expansion of factor 2 (or 3/2 if one uses compressing techniques).
The same drawback: if one knows mx (or my), he can solve for my (or mx) easily.
To prevent this attack, one should send only kÃ¯Â¿Â½P and one finite field element y = c1 m (mod p).
There are other proposals/standards computing y1 and y2 in more complex algorithms from c1, c2, m1 and m2 in order to prevent an eavesdropper, who knows y1, y2 and half the message, say m1, from recovering the other half message m2 or from substituting m1 by his own message.
2.C.
Digital signature 
Elliptic curve digital signature schemes a.
Elliptic curve digital signature algorithm (ECDSA) ANSI X9.62.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 18 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- This is a version of ElGamal elliptic curve digital signature scheme and is an analogue to DSA, Digital Signature Algorithm.
In this document, the hash function H is the Secure Hash Algorithm (SHA-1), whose output e is a 160-bit string.
Step 1.
Initial Setup: All users will use the same underlying finite field Fq, where either q = 2m or q is a prime greater than 3.
Let E be a non-supersingular elliptic curve defined over the finite field Fq. Choose P as a base point of prime order n in E(Fq).
We will work on the group P = {O, P, 2P,..., (n 1)P}.
Step 2.
Key generation: The signer will select a statistically unique and unpredictable (or random) integer d in the interval [1, n 1], and compute point Q = dÃ¯Â¿Â½P.
The signer's private key is d and his public key is Q. Step 3.
Signature generation: The signer will select a statistically unique and unpredictable integer k in the interval [1, n 1], and compute kP = (x1, y1) and check that r = x1 0 (mod n).
If r = 0, then select another k. Compute e = H(M) and check that s = k 1 (e + dr) mod n 0.
If s = 0, then select another k.
The signature for message M is a pair (r,s).
Step 4.
Signature verification: The verifier will compute the values e = H(M), u1 = es1 (mod n) and u2 = rs1(mod n).
Then compute the elliptic curve point u1P + u2Q = (x2, y2), using the signer's public key Q, then the value v = x2 (mod n).
The signature is accepted if v = r.
The security of this cryptosystem does not depend on the choice of the base point P as long as its order n satisfies the requirements: n 
Signature size: To achieve the same security level (in terms of MIPS years to break-in using the best attacks) of DSA (160-bit q and 1024-bit p), or RSA (1024-bit modulus n), the parameter n should have at least 161 bits.
This could help ECDSA to resist against Vaudenay's attack.
Public key size: By the point compression technique, a point (x, y) on the elliptic curve can be represented simply by x-coordinate and a single bit of y-coordinate.
Hence in the above case, a public key size is 161 bits only.
Note that the security of such schemes also depends on the security of hash function that is used.
In current estimation, for short-term security, n should have at least 161 bits; for medium-term security, 180 bits.
One always expect that these lower bounds should be increased as technology advances.
Brown [B00] proved that ECDSA is secure against existential forgery by adaptive chosen-message attack if the goup of points on the elliptic curve is modeled by a generic group and the hash function is collision-resistant.
Nguyen 
Other schemes (Agnew, Mullin 
Instead of computing the inverse k1 in the formula s = k1(e + dr) mod n, we define: s = d1(e + kr) mod n.
Hence, we need to compute only one fixed inverse d1 of the private key d for all messages.
Recall that: kP = (x1, y1), r = x1 0 (mod n), e = H(M).
The signature for message M is a pair (r, s).
To verify signature, we compute: e = H(M), u1 = er1(mod n) and u2 = srÃ¯Â¿Â½ 1(mod n).
Then using the signer's public key Q to compute: u1P + u2Q = (x2, y2) and v = x2 (mod n).
The signature is accepted if v = r.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 19 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- The security of this scheme is based partially on the intractability of the following problem: Given Q = (xQ, yQ), find a point P = (xP, yP), such that s(xP, yP) = (xQ, yQ), where s = (xP mod n), if such a point exists.
This problem is thought to be more difficult than ECDLP.
The existence is also not proven yet.
This scheme is basically similar to a general version of Nyberg-Rueppel's signature scheme with message recovery.
Modified ElGamal digital signature schemes are discussed in Saryazdi [S90], Horster, Michels 
It also requires a hash function H(M, x), for a message M using a key x. Its signature can be smaller than the ElGamal scheme.
The setup and key generation steps are similar as those steps in ECDSA described above.
Signature generation: Select a random integer k in the interval [1, n 1], then compute the point kP = (x1, y1).
Then compute e = H(M, x1) and s = (k + de) mod n.
The signature for message M is a pair (e, s).
Signature verification: Compute the point sP eQ = (z, t), using the signer's public key Q.
The signature is accepted if H(M,z) = e.
The Schnorr scheme is secure against passive attacks but not yet known for active attacks.
In order to resist against some known attacks, the hash function H(M, x) used in this scheme must satisfy two basic conditions: H(M, x) must be almost uniformly distributed with respect to variable x, and be a one-way function with respect to variable M. Otherwise, for fixed message M and value e, if the hash function H(M, x) is not uniform with respect to x, one can compute the point (a, b) = sP eQ, for a random s until the equality e = H(M, a) holds.
This attack yields a signature (s, e) for the given message M.
There is another case: chosen message attack.
One can choose an arbitrary signature (s, e) and compute the point (z, t) = sP eQ.
Then he can solve for message M from the equation e = H(M, z), if the hash function H is not a one-way function with respect to M.
The hash function is not required to be collision-free with respect to M.
If we have: H(M, x) = H(M', x), the signature for message M cannot be used to sign message M' since it depends also on a random number k, hence on a random point kP = (x, y).
2.C.2.
Elliptic curve digital signature schemes with message recovery a.
Nyberg-Rueppel's signature scheme with message recovery ([NR96]) Signature generation: The signer will select a random integer k in the interval [1, n 1]
This is called a one-time key pair (k, R).
Then the signer will compute e and check that e = (x1 + M) mod n 0.
If e = 0, the signer must select another k and repeat.
Compute the integer s = k de (mod n).
Then the signature for message M is a pair (e,s).
Signature verification: One cannot verify directly the signature in this scheme.
The signature is accepted if the message is recovered properly.
This can be achieved by adding redundancy to the message before it is signed and checking the redundancy after it is recovered.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 20 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Message recovery: Compute the point sP + eQ = (z, t).
The message is decrypted by M = (e z) mod n. Nyberg-Rueppel's scheme is similar to Schnorr's scheme in which the hash function H is replaced simply by: H(M + x1) = M + x1.
In Nyberg-Rueppel's scheme, we are interested in recovering the message embedded in the signatures without verifying the signature itself.
In Schnorr's scheme, the receiver can attain the message somehow and use it to verify the signature.
An alternative scheme Signature generation: Embed the message into a point M on the elliptic curve.
Select a random integer k in the interval [1, n 1]; then compute the point R = kP + M = (x1, y1).
The signature is a pair (R,s) where s = k dx1 (mod n).
Signature verification: One also cannot verify the signature in this scheme.
The signature is accepted if the message is recovered properly.
Message recovery: From R = (x1, y1), one can compute the point (sP + x1Q).
Then the message is recovered by computing the point: (sP + x1Q) R = M.
In a more general term, in Nyberg-Rueppel's schemes, the integer s satisfies a signature equation Ad + Bk + C = 0 (mod n), where (A, B, C) is a fixed permutation of (Ã¯Â¿Â½x1, Ã¯Â¿Â½s, Ã¯Â¿Â½1).
Nyberg 
Nyberg-Rueppel's scheme can be also used as a key agreement algorithm in the multiplicative group setup.
El Mahassni, Nguyen 
The setup and key generation steps are similar to those steps in ECDSA described above.
In place of the hash function H, one uses a symmetric key encryption/decryption scheme, Ex and Dx in order to recover the encrypted message.
Signature generation: Select a random integer k in the interval [1, n 1], where the prime n is order of the base point P, as usual.
Then compute the point kP = (x', y').
Then compute: e = Ex'(M), e' = H(e) and s = (k + de') mod n.
The signature for message M is a pair (e, s).
Signature verification: One cannot verify directly the signature in this scheme.
The signature is accepted if the message is recovered properly.
This can be achieved by adding redundancy to the message before it is signed and checking the redundancy after it is recovered.
Message recovery: Compute an integer e' = H(e) and the point sP e'Q = (z,t).
The message is recovered as: Dz(e) = M.
In fact, because of the relation (z,t) = (x', y'), as the same point on the elliptic curve, the encryption E and decryption D, that used x-coordinate as a secret key, can be designed generally as a symmetric key encryption scheme with the key (kP): 1 E = SKE(kP)(M) = e and D = SKE(-kP ) (e) = M. Signature size: This scheme produces a signature of the size equal to the sum of message size and elliptic curve size (or order n).
2.C.3.
Summary of digital signature schemes Digital Signature Signature Generation Signature Message Recovery Schemes Verification ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 21 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- ECDSA (ANSI X9.62) R = kP = (x1, y1) r = x1 0 (mod n) e = H(M) s = k1(e + dr) mod n Signature: (r, s) Agnew, Mullin 
Message is encrypted and then decrypted in a separate scheme.
No.
Message is encrypted and then decrypted in a separate scheme.
No.
Message is encrypted and then decrypted in a separate scheme.
Not directly.
The e' = H(e) signature is accepted sP e'Q = (z,t) if the message is Accept the message recovered properly.
if Dz(e) = M Not directly.
The sP + eQ = (z,t) signature is accepted Message: if the message is M = (e z) mod n recovered properly.
Not directly.
The Message: Nyberg-Rueppel's R = kP + M = (x1, y1) signature is accepted (sP + x1Q) R = M s = k dx1 (mod n) scheme 2 if the message is Signature: (R, s) (alternative) recovered properly.
Table 2.1.
Summary of digital signature schemes Initial setup 
Let E(Fq) be a non-supersingular elliptic curve defined over a finite field Fq. Choose P as a base point of prime order n in E(Fq).
Each user selects a random integer d in the interval [1, n 1], then computes the point Q = dP.
His private key is d and public key is Q.
For all schemes, the sender always selects a random integer k in the computation.
Both sides need a good hash function H. 2.C.4.
Signcryption schemes The original "signcryption" schemes were propsed Zheng and Imai's works, [Z98] and [IZ98]
It is a cryptographic method that fulfils both functions of encryption and digital signature with a smaller cost than the cost required by a typical signaturethen-encryption procedure.
______________________________________________________________________ __________________ Vanstone's scheme e = Ex'(M) e' = H(e) s = (k + de') (mod n) Signature: (e, s) Nyberg-Rueppel's e = (x1 + M) mod n s = (k de) (mod n) scheme 1 Signature: (e, s) A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 22 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Signcryption: The signer will select a random integer k in the interval [1, n 1], and compute kP = (x1, y1), r = H(M, kP) and s = k (r + d)1.
The signature is (r, s).
Unsigncryption: Compute the elliptic curve point K = s(rP + Q), using the signer's public key Q, then check whether H(M, K) = r.
In the other version, compute s = k (1 + rd)1 in signcryption step and compute K = s(P + rQ) in unsigncryption step.
2.C5.
Schnorr's authentication schemes ([S91]) The setup and key generation steps are similar to those steps in the ECDSA described above or in Schnorr's signature scheme.
Initiation: Prover A selects a random integer k in the interval [1, n 1] then computes the point kP = (x1, y1).
Then prover A uses the hash function H to compute the value h = H(0, x1).
Prover A sends to verifier B its identification string I, its public key Q, the signature S for the pair (I, Q) and h. Verifier B then verifies the signature S and send a random integer e [1, n 1] to A. Prover sends to B: s = k + de (mod n).
Verification: Verifier B verifies the pair (I, Q) either by checking the signature S or computing sP eQ = (z, t) and checking that H(0, z) = h.
An attack C can cheat by guessing e and sending to verifier B a wrong proof: h = H(0, x1) where (x1, y1) = kP eQ, for a random integer k and s = k.
The probability for successful guessing e is only (n 1)1.
Verifier B can also choose e freely in order to learn prover A's method of authentication.
Key agreement 
While in a key transfer scheme, one party sends the computed session key to the other parties in a secure way.
2.D.1.
Elliptic curve Diffie-Hellman key agreement ([DH76]) Two users A and B first agree on a base point P on an elliptic curve E. User A will choose a random number a, compute aÃ¯Â¿Â½P, then send aÃ¯Â¿Â½P publicly to user B, while keeping a secret.
User B will choose a random number b, compute bÃ¯Â¿Â½P then send bÃ¯Â¿Â½P publicly to user A, while keeping b secret.
Both users now can compute the common secret key (abÃ¯Â¿Â½P) by one user's secret key and other's public key.
For user A, it is the point aÃ¯Â¿Â½(bÃ¯Â¿Â½P); for user B, it is the point bÃ¯Â¿Â½(aÃ¯Â¿Â½P) = aÃ¯Â¿Â½(bÃ¯Â¿Â½P).
Anyone else could know the public information P, aP, and bP, but it is infeasible to find the secret keys a, b and (abÃ¯Â¿Â½P) (by the property of ECDHP.)
Both ElGamal and Massey-Omura cryptosystems are variants of Diffie-Hellman key exchange scheme.
2.D.2.
Elliptic curve MTI key agreement (Imai, Matsumoto 
User A has (a, QA), where QA = aP and user B has (b, QB), where QB = bP. User A selects a random integer kA, then computes and sends to user B the point KA = kA .QB. Similarly, user B will send to A the point KB = kB .QA, where kB is a random integer.
Each user now can compute the shared secret value K by: For user A, it is K = a1kAKB = a1kAkB aP = kAkBP, For user B, it is K = b1kBKA = b1kBkA bP = kAkBP.
2.D.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 23 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- An alternative version: User A selects a random integer kA then computes and sends to user B two points KA = kAP and QA. Similarly, user B will send to A two points KB = kBP and QB.
Each user now can compute the shared secret value K by: For user A, it is K = aKB + kAQB = (akB + kAb)P.
For user B, it is K = bKA + kBQA = (bkA + kBa)P.
In general, these schemes are vulnerable to a few active attacks, including unknown key-share attacks.
2.D.3.
Elliptic curve Menezes-Qu-Vanstone key agreement ([MQV95]) Setup: One will construct an appropriate elliptic curve E as usual, such that n is a prime factor of its order #E (usually, it is order of the base point P on E.)
Let us define: h = (log2 n)/2.
User A has two key pairs (a1, A1) and (a2, A2), where private keys a1, a2 [1, n 1] and public keys A1 = a1P (that is called long term or static key) and A2 = a2P = (x, y) (which is called the short term or ephemeral key.)
User B also has two key pairs (b1, B1) and (b2, B2), where B1 = b1P and B2 = b2P = (x', y'), with two secret keys b1, b2 [1, n 1].
Let tA = f(A2) = f(x, y) = (x mod 2h) + 2h and tB = f(B2) = f(x', y') = (x' mod 2h) + 2h.
Then two users will do computations using one's own secret keys and the other's public keys.
User A will compute User B will compute an integer eA = (tAa1 + a2) mod n an integer eB = (tBb1 + b2) mod n a point RA = eA(tBB1 + B2). a point RB = eB(tAA1 + A2).
Check if RA = (xA, yA) O. Check if RB = (xB, yB) O. Table 2.2.
Computations in the MQV key exchange scheme Then K = xA = xB is the shared secret value or shared key for both users A and B. Verification: One can observe simply that aiBj = aibjP = bjAi, for i, j = 1, 2.
Hence it is easy to verify the scheme: RA = eA(tBB1 + B2) = [(tAa1 + a2) mod n] (tBB1 + B2) = [(tAa1 + a2) mod n]
The special feature of this scheme requires both public and private keys of both parties implied in the signatures and their verifications.
Hence the MQV scheme can prevent efficiently the man-in-the-middle attack.
Refer also to Law, Menezes, Qu, Solinas 
RSA-type elliptic curve cryptosystems We now mention RSA-type elliptic curve cryptosystems may be both controversial and interesting to many researchers.
There are works on designing such cryptosystems or exploiting the connections with RSA cryptosystems.
2.E.1.
Public key cryptosystem using elliptic curves over a ring ZN a.
Elliptic curves over a ring ZN The elliptic curve over ZN is of the form: Ea,b: y2 = x3 + ax + b, where a, b ZN, and gcd(4a3 +27b2, N) = 1.
In general, over a ring ZN, the set of points in Ea,b(ZN) (including the point at infinity denoted by ON) does not form a group.
The same addition rules defined for an elliptic curve over a finite field cannot be extended to the ring ZN. ______________________________________________________________________ __________________ 2.E.
A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 24 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- The simple reason is that the inversion of a non-zero number n works in modulo a prime p but does not work in modulo a composite number N, if gcd(n, N) 
Under modulo p, for p being some prime factor of N, the elliptic curve Ea,b over ZN is reduced to an elliptic curve Ea , b over the prime finite field Fp, where we denote a = a p = a (mod p).
Let P = (x, y) E(ZN), then Pp = ( x , y ) E(Fp), and (ON)p = Op, the point at infinity of E(Fp).
We may drop subscripts a and b where there is no confusion.
From now on, we are interested in the case that N is a product of two distinct odd big primes p and q. For convenience, we also use the notation q for a prime factor of the composite number N. Do not confuse with the subscript q for finite fields where q = pm. By the Chinese remainder theorem, any x ZN can be represented uniquely as a pair ( x p , xq ) Fp Ã¯Â¿Â½ Fq.
We consider the product (ZN) of two groups E(Fp) and E(Fq).
Hence (ZN) is a group.
We have (ZN) = E(Fp) Ã¯Â¿Â½ E(Fq) = {(Pp, Pq), where Pp = ( x p , y p ) E(Fp) and Pq = ( xq , y q ) E(Fq)} and ON = (Op, Oq).
For the elliptic curve E(ZN), we observe that each point P E(ZN) corresponds to a unique element (Pp, Pq) (ZN), except for elements in which exactly one of the points (Pp or Pq) in the pair is the point at infinity.
Then we have # (ZN) = #E(Fp)Ã¯Â¿Â½#E(Fq).
The ~ number of elements in the set E(ZN) - which is a subset of E (ZN) - is easily computed by: ~ #E(ZN) = (#E(Zp) 1).(#E(Zq) 1) + 1 = # E (ZN) #E(Zp) #E(Zq) + 2.
This number was not used anywhere in the cryptosystems.
Instead we are interested in #(ZN) = #E(Fp).#E(Fq) or MN = lcm(#E(Fp), #E(Fq)). b. Addition rule and factorization algorithm Also let Q = (x', y') E(ZN) corresponding to a unique element (Qp, Qq) (ZN).
The addition operation on E(ZN) is defined by the component-wise addition in each group of the product group (ZN).
That is, P + Q = (Pp + Qp, Pq + Qq).
Particularly, we have the scalar point multiplication formula: kP = (kPp, kPq), for any integer k.
The points (Pp, Oq) and (Op, Pq), for any Pp or Pq that is not the point at infinity, are called non-realizable points.
They cannot be the result of adding any two points on E(ZN) If p and q are very large primes, then the percentage of non-realizable points is negligible.
In fact, the addition defined for E(ZN) above is undefined if and only if the resultant is a non-realizable point of the form [Pp, Oq] or [Op, Pq]
When the point addition would result in non-realizable points with non-negligible probability, one could have a feasible integer factoring algorithm for N.
In other words, one can claim: Lemma: If P and Q are two points on E(ZN) whose addition is undefined, then the knowledge of points P and Q is sufficient to factor N.
In the next section, we will discuss public key cryptosystems, digital signature and key agreement schemes based on elliptic curves over a ring ZN.
We will use the following result that can be proved simply.
Lemma: If MN = lcm(#E(Fp), #E(Fq)), then for any point P E(ZN), and any integer k, we have the identity: (kMN + 1)P = P. As the RSA cryptosystem, two distinct large primes p and q are kept secret and the modulus N = pq is publicly known.
The security of RSA-type elliptic curve ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 25 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- cryptosystems is based on the difficulty of factoring modulus N.
The group orders #E(Fp) and #E(Fq) are served as the trapdoor.
The public key e is chosen to be relatively prime to both #E(Fp) and #E(Fq).
Then e is also relatively prime to MN = lcm(#E(Fp), #E(Fq)).
That is: gcd (e, MN) = 1.
Then the secret key can be defined as: d = e1(mod MN).
Hence we have (ed) Ã¯Â¿Â½P = P. 2.E.2.
RSA-type elliptic curve cryptosystems a.
KMOV elliptic curve cryptosystem Three KMOV cryptosystems were proposed by Koyama, Maurer, Okamoto 
As an analogue of the RSA cryptosystem, the security of these systems are based on the difficulty of factoring n. Type 0 scheme requires computation of the order of a general elliptic curve.
It can be used only in digital signature schemes.
The signature is about twice the message.
To sign a message M, one embeds it as a point P = (x, y) E(ZN), and the signature is the point Q = (u, v) = dÃ¯Â¿Â½P, using his private key.
To verify the signature, the receiver computes the point P = (x, y) = eÃ¯Â¿Â½Q, using the sender's public key, and extracts the message M.
The drawback of this system is also common for all cryptosystems using elliptic curves with large primes p, the Schoof's algorithm to compute the order #E(Fp) is still infeasible.
This scheme cannot be used for a public-key cryptosystem, since knowledge of the trapdoor is required to create a point on E(ZN), that corresponds to a message.
Type 2 scheme is a Rabin-type generalization of type 1, where the public key e = 2.
It also has the 4-ambiguity in decrypted message, as in the original Rabin scheme.
Type 1 scheme is the most practical of three schemes.
To set up, user A has the modulus N = pq where p and q are two distinct large primes, which are kept secret and satisfy either case of these two special cases: Case p q 2 (mod 3): The elliptic curve E(ZN) is of the form E0,b: y2 = x3 + b, where coefficient b is determined by the message, m = (mx, my) Zn Ã¯Â¿Â½ Zn, to be 2 3 2 3 encrypted: b m y - mx (mod N).
(Or also by the ciphertext: b c y - c x (mod N) as we will observe below.)
But we do not need b explicitly in the computation.
Case p q 3 (mod 4): The elliptic curve E is of the form Ea,0: y2 = x3 + ax, where a must be computed by the sender using the message or plaintext m = (mx, my), a 2 3 - (m y - m x )mx 1 (mod N), or by the receiver by the encrypted message or ciphertext c = (cx, 2 3 - cy), a (c y - c x )c x 1 (mod N).
Key generation: In both cases, the elliptic curve orders are easily computed, #E(Fp) = p + 1 and #E(Fq) = q + 1.
Let MN = lcm(p + 1, q + 1) that is also kept secret.
His public key will be N and e, where e is randomly selected such that gcd(e, MN) = 1.
His private key will be d, such that ed 1(mod MN).
Encryption: To send a message to user A, user B will encrypt a message m = (mx, my) using user A's public key e: e.(mx, my) = (cx, cy) over E(ZN) Decryption: User A uses his secret key d to recover the message: d.(cx, cy) = (mx, my) over E(ZN). b. Demytko's elliptic curve cryptosystem ([D94]) Like KMOV schemes, this cryptosystem is defined over a ring ZN.
It uses only the x-coordinate of a point on an elliptic curve.
Its security is also based on the difficulty of ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 26 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- factoring N, where N = pq and p and q are two secret large primes.
The elliptic curve E is of the form E: y2 = x3 + ax + b and gcd (4a3 + 27b2, N) = 1.
Let Ep denote the elliptic group modulo p of elements (x, y) satisfying the equation y2 = x3 + ax + b (mod p) together with the point at infinity O. Its order is #Ep= p + 1 tp.
Then its twist curve E'p has order #E'p = p + 1 + tp.
We do the same for the other prime number q. Key generation: His public key will be a pair N and e.
There are four secret keys d1, d2, d3 and d4 for decryption, which are defined by edi 1 (mod Ni), for 1 i 4 and the moduli Ni are defined as in the table 2.3.
Encryption: The message M is embedded as an x-coordinate of a point P on the elliptic curve E.
We write eP = ((eP)x, (eP)y).
The ciphertext C will be the x-coordinate of the point (eP): C = (eP)x. Decryption: First, we compute: u = C3 + aC + b (mod N).
Then we determine whether u is a quadratic residue modulo p and/or modulo q and refer to the table 2.3.
for the right decryption key (secret key) di.
We have the decrypted message as: M = (di.(C,*))x (mod N), and we can do so without using the y-coordinate.
u= C3 + aC + b(mod N) Modulus Ni Decryption u u M = (d1.(C, *))x (mod N) N1 = lcm (p + 1 tp, q + 1 tq) =1 q =1 ( ( ( ( p u p u p u p ) ) ) ) =1 =1 =1 ( ( ( ( u q u q u q ) ) ) ) =1 =1 =1 N2 = lcm (p + 1 tp, q + 1 + tq) N3 = lcm (p + 1 + tp, q + 1 tq) N4 = lcm (p + 1 + tp, q + 1 + tq) M = (d2.(C, *))x (mod N) M = (d3.(C, *))x (mod N) M = (d4.(C, *))x (mod N) Table 2.3.
Demytko's elliptic curve cryptosystem: moduli and decryptions Knowing prime numbers p and q, it is easy to observe whether the modular equations x2 u (mod p) and x2 u (mod q) have solutions and find those solutions.
But finding a solution for x2 u (mod N) is a much more difficult problem.
It is claimed to be equivalent to factoring N.
One must know p and q to compute Ni's.
The decryption time can be reduced by a factor of 4 if one computes M modulo p and q then combine the result using the Chinese remainder theorem.
This scheme is also used for digital signatures where a sender uses one of his secret keys di to sign a message and the receiver uses the sender's public key to verify the signature.
c. Koyama 
This can be considered a special case of Demytko's scheme.
It is also a complement to KMOV case in term of restriction on prime numbers p and q. Case 1: EN (a, 0): y2 = x3 + ax, a 0 (mod p) If p q 3 (mod 4), it is a case of KMOV cryptosystem.
If p q 1 (mod 4), we have the formulae to find the order of the elliptic curve that is non-supersingular.
The algorithm discussed in chapter 4 will show all four possible values of these orders.
Then the Koyama 
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 27 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Key generation: The public key e can be chosen universally such that gcd (e, #Ep) = gcd (e, #Eq) = 1, for all 4 possible values of each order #Ep and #Eq.The private keys are computed to satisfy conditions edp 1 (mod #Ep) and edq 1 (mod #Eq) for each particular elliptic curve that will be used.
Private keys depend on the message (plaintext and ciphertext).
In order to have a message-independent private key, we can modify a little (to make it similar to KMOV scheme): edp 1 (mod Lp), where Lp is the least common multiplier of all 4 possible values of orders #Ep.
The plaintext m = (mx, my) that is embedded as an elliptic curve point such that the 2 3 - coefficient a (m y - mx ).mx 1 (mod N) must satisfy the condition a 0 (mod N).
Encryption will be performed on the elliptic curve EN (a, 0): y2 = x3 + ax.
The ciphertext is: C = (cx, cy) = e. (mx, my).
2 3 - Decryption: From ciphertext C, the receiver computes ap (c y - c x )c x 1 (mod p) 2 3 - and aq (c y - c x )c x 1 (mod q) to determine the proper elliptic curve and the associated private keys to use for decryption: mp = dp. (cx, cy) over Ep(ap, 0) and mq = dq. (cx, cy) over Eq(aq, 0).
Then using the Chinese remainder theorem, the receiver can obtain the message m = (mx, my) from mp and mq.
If p q = 1 (mod 4), then the elliptic curve modulo q is supersingular and its order is (q + 1).
The scheme is the same as in the previous case, except we fix the value #Eq = q + 1.
Case 2: EN (0, b): y2 = x3 + b, b 0 (mod p) If p q 2 (mod 3), it is a case of KMOV cryptosystem.
If p q 1 (mod 3), there are formulae to find the order of the elliptic curve that is non-supersingular.
The algorithm discussed in chapter 4 will show all 6 possible values of these orders.
Then Koyama 
If p q = 1 (mod 3), again, the scheme is the same as in the previous case, except we fix the value #Eq = q + 1.
d. Elliptic curve cryptosystem of Meyer-MÃ¯Â¿Â½ller ([MM96]) Let N be a publicly known product of two large secret primes p and q, and p q 11(mod 12).
We use the elliptic curve of the form E: y2 = x3 + ax + b over a ring ZN and satisfying the condition gcd (4a3 + 27b2, N) = 1.
Encryption: The sender chooses randomly 0 r ZN, and embeds the message m into a point P = (m2, rm3) on E where a = r3 and b = (r2 1)m6 am2.
Check that gcd(4a3 + 27b2, N) = 1.
Otherwise, if gcd(4a3 + 27b2, N) 
Then the sender computes Q = 2.P = (xQ, yQ).
Let l = lsb (yQ) and type t be yQ represented by a Jacobi symbol t = N .
The ciphertext will consist of (a, b, xQ, t, l).
() 3 Decryption: The receiver computes the unique square root yQ of ( xQ + axQ + b), with type t and the least significant bit l.
Let Q = (xQ, yQ).
Then the receiver computes ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 28 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------6 - the index set I = {1 i s | 2Pi = Q, a2 = y P .x Pi9 }.
The set I must have only one point PI, i and the message is m = y x a .
The security of this cryptosystem is based on the intractability of solving "square root" (or half-point problem) in E(ZN).
Joye 
This can be done simply, since these coordinates are functions of m. Then m2 will be a root of the polynomial h(x) = gcd (f(x), g(x)).
There is a very high probability that we can choose f(x) and g(x) such that h(x) is of degree 1.
Hence we can solve trivially for the root m2.
This cryptosystem is equivalent to the Rabin-Williams cryptosystem because it enables the user to recover the value of square of a message.
Hence, it is equivalent to a factorization problem.
Since m2 has 4 roots modulo N, we can decrypt the message m simply from yQ and its type t and the least significant bit l.
Signature scheme: To sign a message m, we hash a message m by m' = H(m).
Then we find integers r and d ZN* such that for points P = (d2, rd3) and Q = 2Ã¯Â¿Â½P on an elliptic curve of the form E: y2 = x3 + r3 x + b.
We will get xQ = m' and yQ has type t = 1.
The signature for m is (d, r).
Verification: Let P = (d2, rd3) and compute a = r3 and b = (r2 1)d6 ad2.
Compute Q = 2.P on the elliptic curve E: y2 = x3 + ax + b.
The signature is accepted if yQ has type t = 1, and xQ = m' and m' = H(m). e. Elliptic curve cryptosystem of Chua-Ling For further interest, Chua 
Chua-Ling cryptosystem used the similar idea of Meyer-MÃ¯Â¿Â½ller on the singular cubic curve of the form C: y2 = x3 + bx2 over a ring ZN, where N is a publicly known product of two large secret primes p and q, and p q 11 (mod 12).
(Notice that the cubic polynomial has multiple roots; hence the discriminant vanishes.)
Encryption: The sender chooses randomly r ZN \{0,Ã¯Â¿Â½1} and embeds the message m into a point P = (m2, rm3) on C.
Then the sender computes Q = 2P = (xQ, yQ), yQ a = r3, b = (r2 1)m2, l = lsb (yQ) and t = N .
The ciphertext will consist of (a, b, xQ, t, l).
3 2 Decryption: The receiver computes the unique square root yQ of ( xQ + bxQ ) with 3 PI -4 PI -1 () type t and lsb l.
Letting Qp = Q (mod p), the receiver then computes Ip = {1 i 2 | 2Pp,i 6 -9 3 - = Qp and a2 = yPp ,i xPp ,i } and mp = y P x P4 a -1 (mod p).
Similarly, the receiver gets mq p ,i p ,i from the equation: Qq = Q (mod q).
The receiver can have m by using the Chinese remainder theorem such that m = mp(mod p) and m = mq(mod q) Joye 
Hence, with very high probability, one can solve for m2 and then message m. f. Paillier's elliptic curve encryption scheme Paillier ([P99], [P00]
Over each finite field Fp and Fq, the elliptic curve E: y2z = x3 + axz2 + bz3 is the ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 29 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- quadratic twist of an anomalous elliptic curve.
Hence, the elliptic curve orders are: #E(Fp) = p + 2 and #E(Fq) = q + 2.
Therefore, #E(ZN) = (p + 2)(q + 2).
For one encryption scheme, Paillier used the elliptic curve over the ring R = 2 Z/p qZ.
Then he computed: #E(Z/p2qZ) = (p + 2)pÃ¯Â¿Â½#E(Fq).
The twist of this elliptic curve has the order: #E(d)(Z/p2qZ) = p2Ã¯Â¿Â½#E(d)(Z/qZ), where d = -1 . p () For another encryption scheme, Paillier used the elliptic curve over the ring R = Z/N2Z.
Then he computed: #E(Z/N2Z) = (p + 2)(q + 2)pq. Galbraith [G02] proposes a generalization of Paillier schemes over elliptic curves on rings ZN, where N = pq, a product of two large odd primes.
E: y2z = x3 + axz2 + bz3, where gcd(N, 6(4a3 + 27b2)) = 1.
Let M = lcm(#E(Fp), #E(Fq)).
The user needs a point Q = (x : y : z) that has order dividing M in the elliptic curve E(Z/N2Z).
That point can be of the form Q = NQ', where Q' is any ramdom number.
The public key will be N, a, b and Q.
The secret key will be M. Encryption: A message m is embedded in ZN as usual.
Let Pm = (mN : 1 : 0).
The sender chooses a random number r and sends the point S = rQ + Pm to the receiver who has the secret key M. Decryption: The receiver computes: MS = r(MQ) + MPm = MPm = (mMN : 1 : 0).
Given the x-coordinate, one can devide by N and M to recover m. Other works related to Paillier cryptosystems are in DamgÃ¯Â¿Â½rd 
They showed that the RSA-types of elliptic curve cryptosystems provide no significant benefits or advantages over RSA cryptosystems, even though they do resist to some known attacks on the RSA cryptosystems, if those attacks do not use integer factoring algorithms.
Kurosawa, Okada 
Meyer 
HÃ¯Â¿Â½stad [H85]) proposed the low encryption multiplier/exponent attacks that is originally applied to RSA or Rabin cryptosystems when a message is encrypted with many different moduli Ni (to be sent to different users) and the encryption (public) key e is small.
HÃ¯Â¿Â½stad showed that one could solve systems of k congruence polynomials of degree e in polynomial time if Ni 
Roughly, we can have Ni 
This attack is also applicable even when many public keys ei are used instead of one, but e = max{ei} satisfies the above conditions.
For elliptic curve cryptosystems, this attack is called low multiplier attack (on public key).
Koyama 
In case of KMOV scheme against HÃ¯Â¿Â½stad attack (low multiplier attack) in broadcast applications, instead of solving congruence polynomials, one must deals with congruence rational functions that could be transferred to polynomials of bigger degree, Bleichenbacher attack [B97] does not depend on the encryption key (public key) 2 3 2 3 e, and is based on this algorithm to solve the system of equations: b m y - mx c y - cx (mod N).
It is based on a work of Coppersmith who proposed an algorithm to solve polynomial equations: f(x) g(x) 0 (mod N), where f(x) is of small degree (about 232 ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 30 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- and g(x) is a rational function of degree less than that of f(x), and g(x) can be computed in a small number of arithmetic steps.
Wiener [W90] showed the Small decryption key (secret key) attack that one can use the theory of continued fractions to find the secret key d of the RSA cryptosystems and RSA-type elliptic curves cryptosystems.
Later, Pinch [Pi95] showed that possibility if the order of secret key d is at most N1/8.
Homomorphism attacks.
Passive homomorphism attack can be applied when the encryption E and decryption D schemes implemented are homomorphic functions to addition; that is, E(M1 + M2) = E(M1) + E(M2) and D(M1 + M2) = D(M1) + D(M2), where messages M1 and M2 are embedded on the same elliptic curve.
That is, from the signatures for messages M1 and M2, one can forge a signature for the message (M1 + M2) and so on for any linear combination of M1 and M2.
The passive attack using homomorphism is usually probabilistically ineffective.
There is an active attack (chosen-plaintext attack) based on homomorphism.
If an attacker wants a user B to sign a message M, he will send to user B another message: M'= M + E(uM) using B's public key and a random number u. User B's signature for M' is S' = D(M') = D[M + E(uM)] = D(M) + uM.
Then the attacker will be able to forge a signature for message M to be: S = D(M) = S' uM.
A hash function should be applied on the plaintext to destroy its homomorphic property if any.
However, homomorphic property is not the only condition for an RSAtype cryptosystem being vulnerable under chosen message attacks.
Bleichenbacher, Joye 
These attacks, which use the extended Euclidean algorithm, need only one message.
Isomorphism attacks.
Passive isomorphism attack: Two elliptic curves E1: y2 = x3 + a1x + b1 and E2: y2 = x3 + a2x + b2 over a prime finite field Fp, where p 
The change of variables (x, y) (u2x, u3y) will transform E1 to E2.
For elliptic curves defined over a ring ZN the isomorphic property is similar, except the condition u ZN*.
If this situation is satisfied, for any integer d, if we have the scalar point multiplication (cx, cy) = d.(mx, my) on the elliptic curve E1, then we have (u2cx, u3cy) = d(u2mx, u3my) on the elliptic curve E2.
For two randomly given plaintexts (or ciphertexts), (mx, my) and (m'x, m'y), there is a negligible probability to have an element u GF(p)* such that m'x = u2mx and m'y = u3my .
Hence the passive attack using isomorphism is usually probabilistically ineffective.
There is an active attack (chosen-plaintext attack) based on this isomorphism.
If an attacker wants a user B to sign a message M = (mx, my), he will send to user B another message M' = (u2mx (mod N), u3my (mod N)), using user B's public modulus N and a random number u. User B's signature for M' is S' = d.(u2mx (mod N), u3my (mod N)) = (s'x, s'y).
Then the attacker will be able forge a signature for message M to be S = d.(mx, my) = (u2s'x (mod N), u3s'y (mod N).
To resist against this attack, a hash function should be applied on the plaintext Concealing-message problem.
Unconcealable message has its ciphertext the same as the message (plaintext) itself.
Blakley 
But there was no literature showing an analoguous problem for RSA-type elliptic curve ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 31 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- cryptosystems for a long time until 1997.
Joye, Quisquater 
The maximum number of unconcealable messages is bound by (e + 1)2, where e is the RSAencryption key (public key).
Hence the probability that a message is unconcealable for a 1024-bit RSA modulus is as small as about 10299.
But this can be open for some active attacks.
2.E.3.
Elliptic curve digital signature 
Fujioka-Fujisaki-Okamoto's scheme [FFO93] This could be considered an elliptic curve version of the ESIGN (Efficient Digital Signature) that based on Okamoto's digital signature scheme.
The idea is to extend Okamoto's scheme, whose signature involves a one-variable polynomial function, to a scheme involving a two-variable rational function.
Refer to the original paper for a more detailed description.
The elliptic curve used in this scheme has the form CN: y2 = x3 + ax + b over ZN where N = p2q.
The main disadvantage of this scheme is the excessive complexity of advanced calculus used to describe the algorithm.
It makes the scheme less desirable for typical technical people.
The security of this scheme depends on the difficulty of factoring N = p2q.
There is no known attack for this scheme so far.
We did not know whether factoring N = p2q is as difficult as factoring N = pq. Note that the quadratic version of Okamoto's scheme was broken by Brickell 
An analogue of McCurley's scheme (McCurley [Mc88], Boyd 
In order to break this scheme, one needs to break the ordinary Diffie-Hellman scheme and also factor big numbers.
Boyd 
Then the procedure is analogous to the elliptic curve Diffie-Hellman key exchange scheme discussed earlier.
The scheme is still secure if an attacker can factor N or solve the ECDHP in the groups E(Fp) and E(Fq) but cannot do both.
The authors also proved that if there exists an algorithm to solve the ECDHP over a ring ZN, then it can be a feasible algorithm for factoring the modulus N. c. Sakazaki-Okamoto-Mambo ID-based key distribution scheme Okamoto [O88] proposed an ID-based key distribution system whose security depends on the Integer Factoring Problem as in the RSA cryprosytems.
The drawback of this scheme is that it cannot be constructed on an elliptic curve over a ring ZN in a straightforward way because the point corresponding to a user's identity may not be a point on the elliptic curve.
Mambo, Okamato 
The elliptic curve EN(a, b): y2 = x3 + ax + b, where N = pq, the product of two large primes, as in the RSA cryptosystems.
The Center has private key consisting of p, q and k, where k = lcm (#Ep(a, b), (#Eq(a, b)).
Let P be the point on EN(a, b) of order k. Given N, a, b and P, computing k is assumed to be intractable without knowledge of the prime factors p and q. Step 1.
Issuing private key to a user A whose public identifying information is IDA.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 32 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Let iA = h(IDA) be user A's hashed identity.
Suppose that gcd(iA, k) =1.
The Center computes: dA = iA1 (mod k) and SA = dAP ( = iA1 P).
The Center transmits the pair (iA, SA) to user A over a secure channel.
Then the user A's private key is SA and public key is iA.
It follows that iASA = P. Step 2.
Key exchange scheme: First, Alice chooses a random number rA in the interval [1, N 1] and computes the point on the elliptic curve EN(a, b): CA = SA + rAiBP, and sends it to Bob.
Similarly, Bob chooses a random number rB [1, N 1] and sends to Alice the point: CB = SB + rBiAP.
Alice computes the point KAB = rA(iBCB + P) and Bob the point KBA = rB(iACA + P).
Then the share secret point is: K = KAB = KBA = rArBiAiBP.
The above scheme can work also on the ring ZN itself.
Qu, Stinson 
Suppose that gcd(x, y) = 1, Sx = x1P and Sy = y1P.
Then Sxy = k1Sx + k2Sy, where k1x + k2y = 1.
The attack: Suppose that one knows enough public keys Ii and secret key Si (by interacting with the Center) to construct a database D = {x, Sx} for small primes x, using the above lemma.
Given a public key I that can be factored into primes in the database D, he/she can compute the private key SI of that public key I. Advantage features of elliptic curve cryptosystems All the users can use the same underlying finite field that can be selected to optimize the finite field arithmetic.
Thus it requires the same hardware to perform such arithmetic.
Users still can select a different elliptic curve or can change to other elliptic curves at any time for security reasons.
All the known attacks so far can reveal a single private key at a time.
The same effort has to be repeated for other private key.
This is true assuming that each user employs a different elliptic curve.
There is a security risk if multiple users employing the same elliptic curve and the same base point.
It will take only about (k)1/2 times as long to reveal k single private keys on the same elliptic curves.
ECC has higher cryptographic security strength with smaller in key sizes and signature sizes in comparison to other cryptosystems, RSA or DSA.
An estimation by Odlyzko was presented in the table 3.1.
DSA/RSA key size Elliptic curve key size Time to break (MIPS Years) 512 bits 106 bits Insecure 768 bits 132 bits 108 (not recommended) 1024 bits 160 bits 1011 2048 bits 210 bits 1020 2500 bits 239 bits 1023 21000 bits 600 bits 1078 Table 3.1.
Key sizes for comparable security of DSA/RSA and ECC Remark: A MIPS machine can perform a million microprocessor instructions per second.
In cryptography literature, it is usually estimated (optimistically) that a machine rated at 1 MIPS can perform roughly 40,000 elliptic curve additions per second.
A 1-MIPS year (MY) is equivalent to the computing power of a MIPS computer utilized for one year.
______________________________________________________________________ __________________ 2.F.
A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 33 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Computational efficiencies of ECC: faster speed in implementation and execution.
Although the elliptic curve operations (such as additions or scalar point multiplications) require more arithmetic operations than modular multiplications in modulo groups, but, if the same security level is required, we will work on a much smaller size of finite fields for elliptic curves than the size of modulo groups.
As a result, it is estimated that elliptic curve operations are about 8 to 10 times faster than modular multiplication in a modulo group whose order is of the same security level.
There are subsequent advantages from this approach: better storage efficiencies and bandwidth savings, smaller certificates and codes, which then require smaller memory, and low cost of implementation: integrated circuit (IC) chips of smaller number of gates and lower power consumption.
The uses of elliptic curve cryptosystems will have the most benefit in applications in highly contrained and low resources environments, where bandwidth, memory, power and processing capacity are limited, such as smart cards, wireless communication devices and handheld/mobile electronics devices and computers...
Hence elliptic curve cryptosystems will be the most important and efficient cryptographic technology for the next generation products of the Internet, banking, electronic commerce systems and many other security solutions.
For latest work on selecting appropriate key sizes for a cryptosystem, refer to Lenstra 
Chapter 3 Attacks on Elliptic Curve Cryptosystems We will briefly scan many well-known cryptographic attacks or algorithms on the ECDLP, the security core of elliptic curve cryptosystems.
This is an active research area which will provide new algorithms on cryptographic attacks as well as counter-attacks toward the ECDLP.
Running time of algorithms For the running time, one can count on both the number of bit operations and the number of group operations such as elliptic curve additions or scalar point multiplications or other finite field arithmetic operations...
For any integer x, the number of bits b(x) of x is [log2 x] + 1 = [(log x)/(log 2)]
Then we can write: b(x) = O(log x).
Recall the usual notation of running time function L that is usually written as a function of variable log x: L(x, c, ) = O{exp[(c + o(1))(log x) (log log x)1 ]}, where is a real number, 0 1 and o(1) is a number that approaches 0 as x increases to infinity.
When = 0, L(x, c, 0) = O((log x)c'), then the running time is polynomial in (log x).
When = 1, L(x, c, 1) = O[exp(c'log x)], then the running time is fully exponential in (log x).
If written in terms of x, it is L(x, c, 1) = O(xc').
Otherwise, 0 
Fixing x and c, and for in the interval [0,1], the smaller value of will give the quicker running time.
One may distinguish two types of algorithms: General-purpose algorithm attempts to solve general problems; hence its running time depends on the size of the input.
It is independent of the underlying group representation.
Special-purpose algorithm attempts ______________________________________________________________________ __________________ 3.A.
A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 34 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- to solve a particular problem; hence its running time depends not only on the size of the input but also on special features of the input or the underlying group representation.
Algorithms on the discrete logarithm problem We will give brief discussions of most practical algorithms known in literature to find the discrete logarithm m in the equality y = gm. Shanks' Baby-step-Giant-step This algorithm works on any group.
It requires pre-computing a look-up table of powers of the base element g.
Let h = n1/2.
We pre-compute two lists of data: {g0, gh, 2 g2h,..., g h } and {y, yg1,..., ygh}.
Compare them to check if there is a match: guh = yg t, or y = guh+t.
Then m = loggy = uh + t, for 0 u and t h.
This algorithm takes fully exponential running time in length of the largest prime factor of the order n of the group.
Particularly, it is about n1/2 steps (or group operations.)
By its running time, this method is also named a square root method.
It also requires memory size of n1/2.
It is a time-memory trade-off version of exhaustive search.
To resist this attack, we should have the order n of the group divisible by a big prime p, say p 1040 2132.
Pohlig-Hellman's method ([HP78]) This method (also referred as Silver-Pohlig-Hellman's method) reduces the problem to a determination of m modulo pi, each of the primes pi in the prime factorization of n, the order of the group.
Then we use the Chinese Remainder theorem to recover m. e Let n = p1e1 ... ps s be the order of g.
Let p be any prime in the set {p1,..., ps}.
Then 3.B.
z = m (mod pe) = a0 + a1p + ...+ ae1pe1, where 0 aj p 1, for 0 j e 1.
We can a write yn/p = (gn/p)m = (gn/p)z = ( g n / p ) 0 , since gn/p has order p.
Now, a0 is the discrete logarithm of yn/p to the base gn/p.
For a1, we write: 0 ( yg 0 ) n / p = g = (g n /p ) 0 = (g n /p ) 1 .
Each term aj now is a discrete logarithm to the base element gn/p.
Hence it reduces from a difficult DLP to many easier baby-DLPs.
Each baby-DLP can be solved using other algorithms.
Its running time, O(ei(log n + pi)) group multiplications, depends mostly on the largest prime factor.
Hence it works efficiently only when n is a smooth number, that is, all primes pi are small.
Therefore, in order to resist Pohlig-Hellman's algorithm, n should be divisible by a large prime number (
Pollard's rho-method and lambda-method This method is a randomized version of Shanks' Baby-step-Giant-step algorithm, and it requires no significant storage of pre-computations.
The algorithm was described in Pollard [P78] later also explained in much cryptography literature.
In short, we partition the group into 3 subsets, and then perform the following recursive search: xi+1 = xiu, where u is either xi, g or y depending on which subset xi belongs to.
The search is completed until we find a value j such that xj = x2j.
-a 2 (m-a )n / p2 (m-a ) /p a ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 35 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- By its running time, this method is also named a square root method.
This algorithm also works on any group, and it takes about (n/2)1/2/R steps (group operations) if R microprocessors are used in parallel.
Refer to van Oorschot 
When n 
Pollard's "lambda-method for catching kangaroos" is applicable when the result is known to be in a certain range.
If the length of that range is w, then the running time is about w1/2.
The above algorithms, as Shanks' Baby-step-Giant-step, Pollard-rho and PohligHellman, are called generic algorithms.
The algorithms can work on any group and require no special group structure except that each element in the group has a unique representation.
Shoup [Sh97] showed that the lower bounds of running time for generic methods to solve DLP are proved that match the known upper bounds, about O((n)1/2), under some assumptions.
That is, in order to improve the attack efficiently, one must know more about the structure of the group.
There was also a method proposed by R. Silverman 
This method was originally to attack the ECDLP.
Index-calculus algorithm First we try to select an appropriate fixed subset, called the "factor base" B, of small primes gi of the group G, such that most elements in Z * can be represented as p products of such primes.
We hope to be able to find the discrete logarithms logg gi of elements gi in the factor base B to the base point g, by setting up a system of (a large enough number of) linear equations of the form k = ai (logggi) mod(p 1), where gk = g iai . g i B g i B If we can represent the given element y as a factorization over elements gi in the factor base and the base element g: ygk = g ibi , for some random integer k, then we can g i B solve our DLP for x = logg y = bi (log g g i ) - k mod (p 1). g B i This algorithm has a sub-exponential running time: L(p, c, Ã¯Â¿Â½) = exp[(c + o(1))(log p)1/2(log log p)1/2].
It is the fastest general-purpose algorithm for DLP.
The original (or classical) works on index-calculus methods are due to many researchers such as Maurice Kraitchik, A. E. Western 
There are two sieving methods, which are under current active research.
Number field sieve algorithm Lenstra, Lenstra, Manasse 
Its running time is known heuristically as L(n, c, 1/3) = exp[(c + o(1))(log n)1/3(log log n)2/3], where c = 2( 2/3) 2/3 1.526...
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 36 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- It is independent of the size of factors of n.
A general version of this algorithm has the value c = (64/9)1/3 1.923...
Refer to the works of Coppersmith, Odlyzko 
Refer to Gordon [G93] and Schirokauer [Sc93]
For finite field GF(pm), when m 
Function field sieve algorithm (Work of Adleman, Huang, Coppersmith, Semaev...)
The works of Coppersmith and others are considered a special case of function field sieve algorithm.
For finite field GF(pm), when m 
Algorithms on the elliptic curve discrete logarithm problem (ECDLP) There is no known attack of sub-exponential time for this problem.
First, in order to avoid exhaustive search, the order N of the group should be divisible by a prime n 
To avoid the square-root attacks, n should be greater than 2160.
For convenience, we may now assume the base point P in the ECDLP has order n. Shanks' Baby-step-Giant-step It takes fully exponential time in length of the largest prime factor of the order N of the elliptic curve.
To resist against this attack, we should have the order divisible by a big prime n, say n 
This is one of the fastest generic algorithms for ECDLP on nonsupersingular elliptic curves.
It is also claimed that the best general-purpose algorithm for ECDLP is the combination of Shanks' Baby-step-Giant-step method and Pohlig-Hellman method discussed below.
Pollard's -method It takes about (n/2)1/2/R steps (i.e., elliptic curve additions), if R microprocessors are used in parallel.
Refer to van Oorschot 
This is known as one of the best generic algorithms for ECDLP.
It is also claimed that the best general-purpose algorithm for ECDLP is the combination of Pollard's -method and the Pohlig-Hellman method.
A well-known cryptographic fact is that exhaustive search through a k-bit symmetric key cipher takes about the same time as the Pollard algorithm applied to an elliptic curve cryptosystem having a 2k-bit n. Currently, the standard n is required to be greater than 2160.
Pohlig-Hellman's method This algorithm works on any group by exploiting the subgroup structure.
The idea is to determine elliptic curve discrete logarithm m in the ECDLP by determining m(mod pi) for all primes pi in the prime factorization of the order n of the base point P.
Then we use the Chinese remainder theorem to recover m.
This algorithm works efficiently if the primes pi are small.
That is, n is a smooth number.
Therefore, in order to resist the Pohlig-Hellman's algorithm, n should be divisible by a large prime number (
In summary, no generic algorithm on ECDLP can perform substantially better than the Pohlig-Hellman algorithm combined with either Shanks' Baby-step-Giant-step 3.C.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 37 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- or Pollard's -method.
Currently, there is no other breakthrough improvement on implementation of the known attacks or of new attacks.
Method of solving multiple elliptic curve discrete logarithms (R. Silverman 
The idea is to apply the parallelized Pollard-rho method M times to find each logPQi.
In each search, one may encounter two types of collisions: ordinary collisions within itself and special collisions with other searches.
If the running time to find a logPQi is T, then the running time to find all M discrete logarithms logPQi's is TK1/2.
Hence if multiple users are using the same elliptic curve and same base point, there is a security risk, since it takes only about K1/2 times to recover K secret keys on the same elliptic curve.
Therefore, we should choose parameters such that solving each single discrete logarithm is infeasible by itself.
Index-calculus method Over finite fields where the DLP is defined, there is another "additional structure" beyond the "multiplicative structure."
The index-calculus methods take advantage of this extra structure.
It is generally believed that it is much more complicated, or even impossible, to apply index-calculus method to elliptic curves.
In ECDLP, the group of points has no extra structure other than the basic operation: addition of two points.
A similar approach as in DLP, by choosing a "factor base" B, could not work for E(Fq).
The questions are: How to create a factor base for an elliptic curve? And may there be a method without requiring a factor base of elliptic curve points? Flassenberg 
Miller [Mi98] discussed "lifting" points on E(GF(pn) to points on an elliptic curve (Q) where Q is the rational field.
That is, given P E(GF(pn), find an elliptic curve (Q) and a point Q (Q) such that Q P (mod p).
The natural candidate for a factor base is a set of points of small height on (Q).
The height of an elliptic curve point that is defined as the number of bits in the numerator and denominator of the x-coordinate of that point.
But these points are too sparse to generate all points on the elliptic curve by scalar point multiplications.
In order to have such a lifting with probability c, the points need to have a height of at least 2cp, which is impossible.
Even when such a base exists, it is still a very difficult problem to find an efficient method for the lifting.
Recently, Silverman 
The main reason is that a factor base for the ECDLP is exponentially bigger than a DLP factor base.
In summary, the ECDLP is considered more difficult than the DLP for DSA and more difficult than the IFP (Integer Factoring Problem) on which RSA cryptosystems are based.
Application of Weil pairing and MOV reduction attack The Weil pairing can be used to embed an elliptic curve E(Fq) into the multiplicative group of the finite field GF(qk) for some positive integer k.
This helps to reduce the elliptic curve discrete logarithm problem (ECDLP) on the curve E(Fq) to the ordinary discrete logarithm problem in the multiplicative group GF(qk)* = GF(qk)\{0}.
This method is called MOV reduction (proposed by Menezes, Okamoto 
A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 38 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- [MOV93]).
We need an assumption that gcd(#(E(Fq), q) = 1, and it works on both cases, either q = p 
The supersingular elliptic curves automatically satisfy the assumption that gcd(#E(Fq), q) = 1, since if q = p, then E(Fq) = p + 1, while if q = 2m then #E(Fq) must be an odd number.
Let P be the base point of order n used in the ECDLP.
Let Q be a fixed GF(qk)point of order n that is not in the subgroup P, generated by point P.
The mapping defined by Weil pairing, P a en(P, Q), is the embedding of subgroup P into the multiplicative subgroup GF(qk)* of the finite field GF(qk).
The necessary condition for this embedding is obviously that: (a) The order n of point P must divide (qk 1).
Then the finite field GF(qk) contains all n n-th roots of unity.
We need one more condition for MOV working on the finite field GF(qk): (b) The elliptic curve E(GF(pk) contains n2 points of prime order n.
Hence we have E[n](Fq) E(GF(pk).
It was shown that statement (b) implies statement (a) and the proof did not require either condition n| #E(Fq) or n(q 1).
Balasubramanian 
Indeed, since n| #E(Fq), the elliptic curve E(Fq) contains a point P of order n.
The condition n| (qk 1) implies that gcd(n, q) = 1.
Hence the elliptic curve E(GF(ps) contains n2 points of order n, for some positive integer s. Using Frobenius mapping and the critical condition q.e.d. n(q 1), they proved that, in fact, s must be k. We have (b).
Theorem (Balasubramanian 
Then the elliptic curve E(GF(qk)) contains n2 points of order n if and only if n| (qk 1), for some positive integer k. That is, the necessary condition n| (qk 1) is in fact also sufficient for MOV reduction, provided a crucial assumption that n(q 1).
Otherwise the result is wrong even if one assumes that n2 | #E(Fq).
The running time for DLP in this situation will be sub-exponential in log(qk), by index calculus method, L(qk, c, 1/3) = exp[(c + o(1))(log qk)1/3(log log qk)2/3].
In fact, the algorithm is not proved for the case q prime and k 
Refer to Gordon [G93] for the case k = 1.
Hence the MOV reduction is significant only when k is small enough.
Particularly, if we have k (log q)2, its running time will be greater than 2 2 exp[( c' )(log q (log q ) )1 / 3 (log log q (log q ) ) 2 / 3 ] = = exp[(c')log q (3log log q)2/3]
This running time is fully exponential in (log q) and hence there is no significant advance in the MOV reduction.
When k = log q, we can estimate that [(log qlog q)1/3(log log qlog q)2/3] = (log q)2/3.(2log log q)2/3 
Hence the borderline value for k could be log q 
One could choose roughly k0 = (logq)2/[s(log logq)2], for a value s such that 0 
We consider supersingular and non-supersingular elliptic curves separately.
When E is supersingular, the MOV reduction needs the extension field to be of degree k 6 only.
Let #E(Fq) = q + 1 t.
Then the values of k are computed as follows: ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 39 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- q 0 2q 3q 4q 2 3 4 6 1 2 Table 3.2.
Values of k versus t Hence the MOV method is successful on attacking the ECDLP on supersingular elliptic curves.
That is the reason that one generally prefers non-supersingular elliptic curves in applied cryptography.
When E is non-supersingular, to resist the MOV attack, we must have k 
Particularly, the order n of base point P must be checked to satisfy the MOV condition, that is: n(qk 1) for all k (log q)2.
In practice, we do not need value of k to be near (log q)2 (as we also observed above), but k = 20 is sufficient.
In the future, we should replace this value by a number b such that the DLP on GF(qb) is intractable with the up-to-date technology capability.
Assume that n is divisible by a large prime u (or if n is a prime itself, then u = n) in order to resist the Pohlig-Hellman attack.
To ensure the condition: E[u] E(GF(qt)) for each t, 1 t k, it is sufficient to check either u2 #E(GF(qt)) or n(qt 1).
With such requirements, the ECDLP on non-supersingular elliptic curves has no known sub-exponential time algorithm.
The best-known algorithms (which still run at exponential speed) are Shanks' Baby-step-Giant-step and MOV reduction followed by a number field sieve (Koblitz, 1991), or combination of Pollard- and Pohlig-Hellman methods.
Refer to [HMV93].
Currently, there is no other breakthrough improvement on implementation of the known attacks or of new attacks.
Supersingular elliptic curves #E(Fq) 2 Over Fp, p 
Table 3.3.
A checklist of orders of supersingular elliptic curves that should be avoided Chao, Tanada 
Hence in order to check that k 
SSA attack (Smart-Satoh-Araki attack) The SSA attack is to solve the ECDLP on non-supersingular elliptic curves of trace t = 1 or #E(Fp) = #(Fp), where p 
They are called anomalous curves.
The idea is to reduce the ECDLP to a simpler equation in a p-adic field.
There are a few independent works on this problem by Smart, Samaev and Araki 
The generalized work is done recently by RÃ¯Â¿Â½ck.
The SSA attack cannot apply to other cases since its proof uses the essential identity: #E(Fp) = #(Fp) = p.
In order to resist this attack, the SSA condition (or anomalous condition) should be satisfied: #E(Fp) #(Fp) = p.
One should note that the anomalous binary curves (ABC's) or "Koblitz curves," which are defined over finite fields GF(2m), are not susceptible to the Smart-Satoh-Araki 3.E.
t2 k ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 40 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- attack.
It was known that trace-1 elliptic curve case was mentioned earlier at the West Coast Number Theory conference, 1996, as a "well known fact" and hence unpublished.
Araki 
The method is based on an elliptic curve version of Fermat quotient that is defined as Lp(a) = (ap1 1)/p (mod p) Fp, for a such that gcd(a, p) = 1.
It is well-defined because of Fermat's Little theorem, ap1 1 0 (mod p).
The detailed proof is out of context.
It utilized the concept of formal group, associated with an elliptic curve, and its properties.
This algorithm has a linear running time O((log p)3) to solve the ECDLP on an anomalous elliptic curve.
It also works on non-prime finite fields Fq, where q = pr, where p 
Smart's work ([Sm99]): claimed that this attack works just on prime finite fields.
The idea is to reduce the ECDLP to a simpler equation in a p-adic field.
We consider the ECDLP as usual, Q = mÃ¯Â¿Â½P, on an elliptic curve, and neither point has order two.
We then lift these points to points P and Q on the same elliptic curve but over the p-adic field Qp by P = (x, y) where x is the x-coordinate of P and y is computed via Hensel's lemma, and similarly for the point Q .
Then we have: Q - mP = R E1(Qp), where En(Qp) = {P E(Qp): vp(x(P)) 2n} {O}, as a subgroup of the elliptic curve E(K), and vp is the discrete valuation in Qp.
Then we have two following equivalence relations: E0(Qp)/ E1(Qp) E(Fp) and En(Qp)/En+1(Qp) E1(Qp)/ E2(Qp) Fp, for n 1.
If the elliptic curve satisfies the condition: #E(Fp) = #(Fp) = p, we can multiply the above equation by p: pQ - mÃ¯Â¿Â½ pP = pR E2(Qp).
Taking the p-adic elliptic logarithm p (which is easy to compute but its context is not able to be described yet within this document), we have: p( pQ m. pP ) = p( pR ) 0 (mod p2).
This reduces the ECDLP to a single linear equation of one unknown over the p-adic field Qp. Its solution is m = p( pQ ) / p( pP ) (mod p).
This attack has a linear running time O(log p), since the only non-trivial computation needed to be performed is to compute pQ and pP .
Both computations need a number of (log p) group operations on an elliptic curve.
Semaev [Se98] showed a more general result on the elliptic curve discrete logarithm problem in a subgroup of order p of an elliptic curve E(Fq), where q = pk. Semaev showed how to construct an isomorphism from such a subgroup to an additive subgroup of some finite field GF(pk).
Then the problem can be solved in polynomial running time, O(log p) field operations.
As an immediate result, the ECDLP in anomalous elliptic curves over prime finite fields then can be solved easily in polynomial running time.
RÃ¯Â¿Â½ck [R97] generalized the result of Semaev [Se98]
3.F.
Differential and power attacks More rigorous proofs for those estimations are still needed in order to evaluate and compare the security of various cryptosystems.
More powerful attacks are expected for the years to come when elliptic curve cryptosystems are more extensively studied and widely implemented.
There are a few estimations on the security of elliptic curve cryptosystems, in comparisons with other cryptosystems, scattered in cryptography ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 41 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- literature.
For example, refer to the table 3.4 for the case n 
(Length System Private key Signature size Encrypted 100Public key Ã¯Â¿Â½ in bits) parameter bit message RSA N/A 1024+64 2048 1024 1024 DSA 2208 1024 160 320 depend ECC 481 161 160 320 321 Table 3.4.
Comparisons of the cryptosystems RSA, DSA and ECC (Ã¯Â¿Â½: For time to break of about 1011 MIPS years) The software attack is to use an exhaustive search for a solution of an ECDLP.
The hardware attack is to build special-purpose hardware for a parallel search by Pollard- method that is considered one of the best algorithms so far, or used in combination with other methods or even by new algorithms hopefully to be developed.
Both software and hardware attacks are still infeasible for elliptic curve cryptosystems with at least n 
Side-channel attacks: The timing and differential power attacks belong to the family of attacks, called "side-channel" attacks, which devise to exploit the leakage of information from implementations of cryptosystems.
Timing attacks, which are proposed by Kocher [Ko96] are based on repeatedly measuring the exact exe
Kocher also proposed attacks using differential power analyses based on the power assumption of cryptographic devices.
This later type is usually referred as Simple Power Attacks (SPA).
To defend against such attacks, in general, one should uniformize or homogenize the computations to make running time and power independent of key bits or randomize inputs and key bits.
Particularly for elliptic curve cryptosystems, one should use Montgomery's method for point scalar multiplication or add dummy operation to homogenize the point adding operations.
Differential fault 
Refer to Biehl, Meyer 
The differential fault attack induces computational errors to the device and deduce key bits from the leaked information by the faulty results.
To defend againt DFA attack, one should check the consistency of the computational results.
For example, for elliptic curve cryptosystems, verifying the resulting point being on the elliptic curve is implicit consistency relation which should be used at all time.
The differential power attack attack applies statistical tests to intermediate results in order to detect correlations between plaintext and ciphertext.
To defend against DPA attack, one should decorrelate the intermediate results, key bits, plaintexts and ciphertexts by randomization.
Particularly for elliptic curve cryptosystems, we can also use the randomized projective coordinates.
Later works, such as Bellezza [Be01], also discussed many methods of counterattacks against the side-channel attacks, especially for the elliptic curve cryptosystems, such as: moving to a random isomorphic elliptic curve, changing the field representation, ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 42 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- (such as using projective coordinates...) and adding a random point to the input and subtracting a suitable multiple of that point at the end.
But in a general sense, designers should be aware that design and implemention of a countermeasure against one physical cryptanalysis may benefit another attack or attacks.
Chapter 4 Implementations of Elliptic Curve Cryptosystems We will discuss many technical issues in implementations of elliptic curve cryptosystems such as how to implement finite fields, elliptic curves and arithmetic operations on them.
More techniques and algorithms are likely being developed to improve the efficiency of elliptic curve cryptosystems.
An elliptic curve cryptosystem requires a process of setting up common system parameters.
These parameters, once generated, will be used by all users within a group using that cryptosystem.
Each user will have his/her own pair of private and public keys.
Implementations of finite fields First, one has to decide which finite fields will be used for an elliptic curve cryptosystem.
One must choose an appropriate finite field and its basis to represent field elements.
4.A.1.
Finite fields In order to implement finite fields, we will deal with these tasks: Selecting the underlying finite field Fq. Selecting a basis representation for the finite field elements, Implementing the arithmetic on the finite field Fq.
The cost, speed and feasibility of elliptic curve cryptosystems depend on the finite field Fq, where q = pm, on which it is implemented.
There are usually two finite fields to work on: prime finite field Fp = Zp (i.e., m = 1) when p is a prime number 
Prime finite fields Fp, where p is a large prime number 
The minimum threshold of the choice of p should increase as new technology and theory develops to attack the ECDLP.
In fact, it is the order of an elliptic curve that is the first factor in selecting the elliptic curve.
As we will discuss later, that order must be divisible by a prime 
It is also within a relatively small range around p, the order of Fp, as we knew already: | p #E(Fp)| 1+ 2 p .
Mersenne primes.
In such finite fields, we can perform efficient subfield multiplication, by reducing a 2n-bit number to roughly 1.5n bit value by "folding" the upper half into the lower half.
The small value of c helps to improve the subfield modular reduction.
There are two special types of OEF that can provide additional advantages on arithmetic operations.
Type I OEF: p = 2n Ã¯Â¿Â½ 1.
This field allows for subfield modular reduction with very low complexity.
For example, good choices for p are: 231 1 and 261 1.
Example of implementation of Type I OEF: GF((261 1)3) whose reduction binomial is x3 37.
2 ( s -1) Number theory tip Theorem: For an integer m 2, for w GF(p), the binomial xm GF(p) if and only if the following two conditions are satisfied: (i) Each prime factor of m divides the order e of element w in divide (p 1)/e; (ii) p 1 (mod 4) if m 0 (mod 4).
Corollary: If w is a primitive element for GF(p) and m is a divisor binomial xm a is irreducible over GF(p).
An important trivial result is for the case m = 2.
The binomial over GF(p) when w is a primitive element.
w is irreducible in GF(p), but does not of (p 1), then the x2 w is irreducible ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 59 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Type II OEF: has an irreducible binomial xm 2.
This field allows for a reduction in the complexity of extension field modular reduction since multiplication by w can be implemented using shiftings.
Example of Type II OEF: GF((263 259)2), GF((263 259)3) and GF((263 259)4). b.
The elliptic curves Over OEFs GF(pm), the elliptic curves have the form: y2 = x3 + ax + b, unless for the case p = 3, one uses a non-supersingular elliptic curve of the form: y2 = x3 + ax2 + b. Refer also to Baier [B01]. c. Implementation issues The inverse algorithm is the most important algorithm to discuss in implementation works.
Over OEFs, authors developed and modified some efficient advanced algorithms implemented in typical finite fields discussed earlier.
Refer to Bailey, Paar 
Kim, E. J. Lee 
They also proposed a new inversion algorithm, called MAIA (Modified Almost Inverse Algorithm), which is suited especially for OEFs.
Hoshino, K. Kobayashi, T. Kobayashi 
This method is efficient for small values of m. Implementations of elliptic curves Now, we will discuss issues on implementing elliptic curves.
Related problems are choosing an appropriate order, computing the order of a given elliptic curve, and constructing a cryptographically good elliptic curve for a cryptosystem.
4.B.1.
Conditions for selecting appropriate elliptic curves The order of the elliptic curve, N = #E(Fq), must be divisible by a prime number n that is sufficiently large, n 
This is to resist against the Pollard -algorithm.
The order n of a base point P must satisfy the MOV condition: n (qk 1) for all values k 
In practice, k = 20 is sufficient.
The best-known attacks on an elliptic curve cryptosystem satisfying these two conditions are a combination of either Pollard- or Shanks' Baby-step-Giant-step and Pollard-Hellman algorithms.
The order of the elliptic curve E must also satisfy the anomalous (or SSA) condition over prime finite fields, #E(Fp) p to resist the SSA attack.
The choice of point P of order n is not a security factor.
In fact, given an elliptic curve, there are many different points having that order which can be chosen.
Cofactor We denote by n the order of the base point P on the elliptic curve whose order is denoted by N. Usually, we should have either N = n or N = nl, where l is a small integer, called a cofactor.
In group theory, we call l the index of a subgroup generated by group element P, denoted by P, in the group E. 4.B.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 60 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Recall the inequalities of the order of an elliptic curve, we have: q + 1 2q1/2 #E(Fq) = N q + 1 + 2q1/2.
Then (q1/2 1)2/n N/n = l = (q1/2 + 1)2/n.
We can observe that l must be an integer and the difference of the upper and lower bounds of l is d = 4q1/2 /n.
Hence if n 
Therefore, the order of the elliptic curve can be computed as: #E(Fq) = N = n.l = n (q1/2 + 1)2/n, if there exists a point on E of order n 
Furthermore, the condition n 
Therefore, there is exactly one subgroup of order n in E.
This is directly from the well-known Sylow's third theorem in group theory and the subgroup is also called the Sylow n-subgroup.
4.B.2.
Methods of constructing elliptic curves There are four methods for constructing an elliptic curve in cryptography.
Generating random elliptic curves.
Using the Hasse-Weil theorem (on composite extension finite fields).
Using selected orders of elliptic curves or also referred as Complex Multiplication (CM) methods.
Using special elliptic curves such as Koblitz curves.
a.
Using a random elliptic curve We select an elliptic curve at random and compute its order by some algorithm.
For special elliptic curves, or over relatively small finite fields, there are a few effective formulas or algorithms for the order.
The best-known method for a general case is Schoof's algorithm, together with its improvements and/or extensions.
The advantages: One can change the elliptic curve as frequently as possible for security reasons.
In order to break into an elliptic curve cryptosystem, the attacker should use an algorithm to solve the ECDLP that can work on any elliptic curve rather than some particular classes of weak elliptic curves.
The disadvantages: It is tedious and still complicated to use Schoof's algorithm (and even its improved versions) to find an elliptic curve of particular order.
It is more difficult, generally, to implement a random elliptic curve efficiently, while we can optimize implementation on specific elliptic curves, such as in Koblitz curves and some cryptosystems using supersingular elliptic curves.
It is time-consuming to generate an elliptic curve and to perform operations on a general elliptic curve.
Other implementations, such as compressing and recovering a point, may need more computations than in some particular cryptosystems. b. Using Hasse-Weil's theorem This method is to construct an elliptic curve over a finite field GF(2m) where m is a composite number.
We first construct an elliptic curve over a finite field GF(2n) for some small factor n of m such that we can compute its order easily.
Then we lift it to an elliptic curve over a finite field GF(2m) where its order can be computed rather easily using the Hasse-Weil's theorem.
We should compute rather easily that #E(GF(2n)) = 2n + 1 t, then we will have #E(GF(2m)) = 2m + 1 m/n m/n, where and are complex numbers satisfying the ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 61 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- equation qT2 tT + 1 = (1 T)(1 T).
More practically, + = t and = q = 2n.
Then the power sum Lk = k + k is the k-th term in the sequence of symmetric functions: L1 = t, L2 = t2 2q, and for all k 3, Lk = tLk 1 q tLk 2.
The sequence Lk is usually called Lucas sequence.
The order #E(GF(2m)) then has a small factor, namely #E(GF(2n)).
This method of choosing an elliptic curve works on composite extension finite fields and can create only a limited number of elliptic curve orders.
This construction method can increase the performance in generating elliptic curves and doing elliptic curve operations.
But in the security aspect, these elliptic curves (also referred as subfield elliptic curves) are considered weak curves.
c. Complex Multiplication (CM) methods A Complex Multiplication method allows choosing an appropriate elliptic curve order, before constructing explicitly an elliptic curve of that order.
In practice, this method is fast, and the big advantage is to eliminate the need for a point counting algorithm.
Two methods mentioned in literature are due to Atkin 
Atkin-Morain method [Mo91] The method works on a prime finite field Fp. Recall that #E(Fp) = p + 1 t, where 2 t 4p.
It is based on a theorem of the primality-testing algorithm using elliptic curves.
Theorem: Let p be a prime that can be written as 4p = t2 + Ds2 for a given D.
Then there exists an elliptic curve E defined over Fp such that 4.#E(Fp) = (t 2)2 + Ds2.
We call D a Complex Multiplication discriminant for p, or the elliptic curve E has CM property by D, or in fact, by (D)1/2.
If we know D for a given curve E, we then can solve for t (and s) in the equation: 4p = t2 + Ds2, and know the order #E(Fp).
Atkin-Morain algorithm: Compute t = p + 1 #E(Fp) = p + 1 N. Find an integer s and a square-free positive integer D such that Ds2 = t2 4p.
This step can be done since if N is an order of an elliptic curve #E(Fp), we must have t2 4p.
Hence A = 4p t2 0, and it can be written uniquely as A = Ds2, where D is a square-free positive integer.
Then we write: 4p = t2 + Ds2.
Construct the Hilbert polynomial HD(X) of j(D1/2), using the above formula.
Find a root r of the equation HD(X) 0 (mod p).
Create a non-supersingular elliptic curve whose j-invariant is r.
This algorithm can be generalized over finite field Fq, where q = pm.
Although it is possible to choose the order of an elliptic curve before choosing the underlying finite field, in usual cryptographic practice, one prefers to choose the finite field in advance so one can exploit some efficient implementations.
This method usually generates small d.
The subset of elliptic curves generated by this method is considerably smaller than the number of elliptic curves available.
Those elliptic curves are thought to be insecure, but no weakness is known so far.
Refer to Miyaji ([Mi91], [Mi93]
Lay-Zimmer method [LZ94] This method works on finite fields of characteristic 2 and also over prime finite fields.
It solves the following problems: ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 62 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Given an integer N 
The algorithm is based on constructing an elliptic curve E(GF(2m)) that has a given j-invariant.
However, the rest of the algorithm is based heavily on the algebraic number theory whose context is too complicated to be described in this document.
Refer to MÃ¯Â¿Â½ller 
For CM methods and other works on Koblitz cureves, readers may refer to Koblitz ([K90],[K92]
There is current research mentioning general doubts about constructing elliptic curves extra internal structure, such as with special coefficients (i.e., Koblitz curves), with special Complex Multiplication property and/or over composite extension finite fields.
There is a tradeoff between performance and security in implementing elliptic curve cryptosystems using such special curves and/or finite fields.
4.B.3.
Finding a point of given prime order on an elliptic curve The order n of a point P O on an elliptic curve is a positive integer such that nP = O and mP O for any integer m such that 1 m 
The order n of a point must divide the order N of the elliptic curve.
In fact, it is true for any group.
If the elliptic curve order N = #E is a prime number, then the group is cyclic, and obviously all points except the point at infinity O are of order N. Choosing a point P of prime order n: A simple method is usually applied in cryptographic practices when n is a large prime.
Then the factor l = #E/n will not be divisible by n. Choose a random point Q O on the elliptic curve E, then verify whether the point P = lÃ¯Â¿Â½Q has order n.
This can be done simply by checking that nÃ¯Â¿Â½P = O.
(Since n is prime, there is no other positive integer m 
If it is true, then P = lÃ¯Â¿Â½Q is the point we need; otherwise, choose another point Q and repeat.
4.B.4.
Methods/formulae to compute the order of an elliptic curve It should be noted that it is easy to check whether the number of points on an elliptic curve is correct when it is known, while an efficient algorithm to find out that number is still a difficult task.
In chapter 1, we already presented formulae and algorithms for counting the order of an elliptic curve group, such as Hasse-Weil theorem, direct formulae using Legendre symbol and trace function, Shanks' Baby-step-Giant-step algorithm and Schoof's algorithm. a.
The order of an elliptic curve of the following special forms Ep(a, 0): y2 = x3 + ax, for a 0 (mod p) and p 1 (mod 4) ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 63 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- or Ep(0, b): y2 = x3 + b, for b 0 (mod p) and p 1 (mod 3), over a prime finite field Fp are discussed thoroughly in Bressoud [B87] and Ireland 
Case 1.
For prime p 1 (mod 4) and Ep(a,0): y2 = x3 + ax, for a 0 (mod p).
Let r = s + it be a complex prime (where s and t are integers,) and let r = s it be the complex conjugate of r, which satisfy the conditions r 1 (mod 2 + 2i) and p = r r = s2 + t2.
Let (r) = (s + it) = s be the real part of number r.
Then #Ep(a, 0) = p + 1 2[R4(a) r ], where the symbol R4 is defined by R4(x) = x(p 1)/4 (mod r).
The orders in this case are always even.
Explicitly, the elliptic curve orders will fall into one of only four cases listed in this table.
The order #Ep(a, 0) is If R4( a) = (a)(p 1)/4 (mod r) 1 p + 1 2( r ) = p + 1 2s 1 p + 1 2( r ) = p + 1 + 2s i p + 1 2(i r ) = p + 1 2t i p + 1 2(i r ) = p + 1 + 2t Table 4.4.
Orders of elliptic curves Ep(a,0): y2 = x3 + ax, a 0 (mod p), over a prime finite field Fp, p 1 (mod 4) Observe that r 1 (mod 2 + 2i) or (2 + 2i) | (r 1) = [(s 1) + it].
Hence we derive a relation on their squares of absolute values.
It is: 8 | [(s 1)2 + t2] = p + 1 2s.
So we can solve the system of equations s (p + 1)/2 (mod 4) and p = s2 + t2 for values s and t, such that 1 s, t 
Then choose and check an appropriate value of r = Ã¯Â¿Â½ s Ã¯Â¿Â½ it 1 mod (2 + 2i).
Case 2.
For prime p 1 (mod 3) and Ep(0, b): y2 = x3 + b for b 0 (mod p).
Let w be a non-trivial cubic root of 1, (i.e., w2 + w + 1 = 0,) and w = e2i/3 = (1 + 1/2 i3 )/2.
Let r = s + wt be a complex prime, where s and t are integers, satisfying the conditions r 2 (mod 3) and p = r r = s2 st + t2.
In this case, we note that w2 = (1 i31/2)/2 = w and r = (s t) wt, for simpler calculations.
Then #Ep(0, b) = p + 1 + 2[R6(4b) r ], where the symbol R6 is defined by R6(x) = x(p 1)/6 (mod r).
Explicitly, the elliptic curve orders will fall into one of only six cases described in table 4.5.
If R6(b) Equivalently, if R6(4b) = The order #Ep(0,b) is = b(p 1)/6 (mod r) (4b)(p 1)/6 (mod r) (p1)/3 u=4 (mod r) 1 p + 1 + 2( r ) = p + 1 + 2s t u 1 p + 1 + 2( r ) = p + 1 2s + t w.u w p + 1 + 2(w r ) = p + 1 s + 2t w.u w p + 1 + 2(w r ) = p + 1 + s 2t 2 2 w .u w p + 1 + 2(w2 r ) = p + 1 s t 2 2 w u w p + 1 + 2(w2 r ) = p + 1 + s + t Table 4.5.
Orders of elliptic curves Ep(0, b): y2 = x3 + b, b 0 (mod p) over a finite field Fp, p 1 (mod 3) 4.B.5.
Schoof's and Satoh's algorithm for point-counting Refer to chapter 1 for a short summary of development of the algorithms by many researchers such as Schoof, Atkin, Elkies, Couveignes and Lercier.
We choose not to go ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 64 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- deeply into the theory behind these developments of the algorithms at the present time, because of the heavy burden of introducing a lot of difficult materials of the mathematics underlying.
We have discussed how to represent elements of finite fields and how to build an elliptic curve over the underlying finite fields for an elliptic curve cryptosystem.
In the next section of this chapter, more features or issues on the implementations of operations of such cryptosystems will be discussed.
They are scalar point multiplication formulae and algorithms, representations of points on an elliptic curve and special algorithms on Koblitz curves and composite extension finite fields and other topics.
Implementations of elliptic curve arithmetic operations Many topics in implementations of arithmetic operations over elliptic curves will be discussed in this section: scalar point multiplications, methods representing points of an elliptic curve and Complex Multiplication methods...
The most basic operation is adding two points or doubling a point on an elliptic curve.
It is more expensive computationally than a basic operation in a symmetric key cryptosystem (a block encryption/decryption).
But it is still much faster than a basic modular multiplication over a cyclic group whose order is of the same security level.
We now discuss efficient algorithms to expedite implementation procedures in elliptic curve cryptosystems.
4.C.1.
Scalar point multiplication: basic methods One crucial operation is scalar point multiplication since it determines the speed of an elliptic curve cryptosystem.
We will multiply a point P on an elliptic curve E by a positive integer k. By definition, kP = 1+ 4+ L 4P .
This problem is analogous to P 4 24+3 P 4.C. raising an element to the k-th power in the multiplicative subgroup GF(q)*. a.
Double-and-add method This most basic method uses the binary expansion of the number k. Let write k = (kr1,..., k0) in base 2, where kr 1 = 1 and r = log2 k + 1.
Let Pr 2 = P.
Then compute Pi 1 = 2Pi + kiP, for all i, r 2 i 0.
Then kP = P1 = 2P0 + k0P.
This method requires (r 1) doublings and probabilistically about (r 1)/2 additions or at most (r 1).
Observe that we can reduce the number of arithmetic operations when the number of bits 0 is increased.
This is the basic idea for methods, which try to improve the implementation of scalar point multiplication.
b. Addition-subtraction method For elliptic curve implementation, the methods, which included subtractions, are more attractive than the corresponding methods, which included divisions in calculating power in finite fields.
The reason is division or inversion in finite fields is a more costly operation than multiplication, while subtraction is just as costly as addition in elliptic curve operations.
The basic method uses the binary expansion of k and 3k.
Let l = 3k = (lr1,..., l0) and k = (kr1,..., k0) such that the leftmost bit lr1 must be 1.
That is, a few leftmost bits of k are added bits 0 from the canonical binary form of k. Let Pr 1 = P.
Then compute Pi 1 = 2Pi + (li 1 ki 1)P, for all i such that r 1 i 2.
Then kP = P1 = 2P2 + (l1 k1)P. ______________________________________________________________________ __________________ k terms A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 65 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- This method requires (r 2) doublings and probabilistically about (r 2)/2 additions/subtractions or at most (r 2).
This method in fact is an easily described version of the following method.
c. Addition-subtraction method using NAF We now use the canonical encoding called the non-adjacent form (NAF) of scalar k.
This coding employs a signed binary expansion (using 0 and Ã¯Â¿Â½1) that has the property that no two consecutive coefficients are nonzero.
The NAF of an integer is unique and has the fewest nonzero coefficients of any signed binary expansions.
There are many ways to construct the NAF.
One way is just described previously, using bits in k and 3k.
The NAF can be computed similarly by the same method for the binary form.
That is, repeating dividing by 2 to collect the remainders, except an important rule: for the nonzero remainder, the corresponding quotient must be even.
This exception helps to make the next remainder be zero.
Let k be in NAF, k = (kr1,..., k0).
Let Pr1 = P.
Then compute P i1 = 2Pi + ki1P, for all i, r 1 i 1.
Then kP = P0 = 2P1 + k0P.
This method requires (r 1) doublings and probabilistically about (r 1)/3 additions or at most (r 1)/2.
Eventually, we can combine this method with the sliding window method for a more efficient implementation - the signed binary window method that will be discussed later.
d. m-ary method (or 2d-ary method) This method is generalized from the double-and-add method, where the m-ary expansion is used instead of binary form, where m is a power of 2.
Let m = 2d, where d 
We start with the binary expansion of the number k = (ks1,..., k0), where we may pad an extra number of bit 0's to the left side of the bit string to make s = d.r for some integer r.
Then we have the m-ary expansion of k of the form k = (Kr1,..., K0) where each Ki is a d-bit string and Kr1 (0...0).
First we pre-compute all points 2P, 3P,..., (2d 1)P.
They will cover all possible points of the form KiP.
We look up for the point Pr2 = Kr1P, and compute Pi1 = 2dPi + KiP, for all i such that r 2 i 0.
Then kP = P1 = 2dP0 + K0P.
This method requires (2d 2) pre-computations (and memory storage), (r 1)d = s d doublings and probabilistically about (r 1)(1 2d) additions.
We can observe that the larger d is, the more pre-computations are needed.
With a little calculus, we can find the optimal d to minimize the total of additions: A(s, d) = 2d 2 + s d + [(s/d) 1] (1 2d) .
Bit recoding techniques, such as signed binary expansions, are also used to improve the binary or m-ary methods.
Refer to KoÃ¯Â¿Â½ [Kc91] and Eeciolu 
e.
The 2d-ary NAF form It is possible that one can combine the addition-subtraction method with the 2dary method.
Particularly, the addition-subtraction method using the 2d-ary NAF form that is a binary form with the property that there is at most one non-zero term in d consecutive coefficients.
This form always uniquely exists and is easy to compute.
The computing method is similar to that for the NAF form, except that the corresponding quotient to the ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 66 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- non-zero remainder must be divisible by 2d1.
The pre-computation must store all points: Ã¯Â¿Â½P, Ã¯Â¿Â½3P,..., Ã¯Â¿Â½(2d 1 1)P.
The addition-subtraction method is a special case for d = 2.
4.C.2.
Scalar point multiplication: advanced methods a.
Sliding window method ([Kc95]) This method aims to separate zero words so we can skip an addition in the m-ary method discussed above.
Instead of decomposing k = (ks1,..., k0) into words of d-bit length, we now decompose k into zero and nonzero words, or windows Wi of varying lengths li.
Let d be the maximum length of all nonzero windows.
Then we need to precompute only "odd scalar multiplying" points 3P, 5P,..., (2d 1)P We write k = (Wr 1,..., W0) where Wr 1 is a non-zero window (or window number). l Look up for Pr 2 = Wr 1P.
Then compute Pi1 = 2 i Pi + WiP, for all i such that r 2 i 0.
Then kP = PÃ¯Â¿Â½ 1 = 2l0 P0 + W0P.
There are two strategies to partition a binary expansion into windows: constant length and variable length nonzero windows.
Constant length nonzero windows This strategy tries to produce zero windows of arbitrary length and nonzero windows of a fixed length d.
A nonzero window will start when a bit 1 is encountered as we scan the bits from rightmost bit to leftmost.
This method requires (2d 2)/2 = 2d1 1 pre-computations (and memory storage), (s d) doublings and probabilistically about A additions, where A is the number of non-zero windows, A s/d.
Refer to KoÃ¯Â¿Â½ [Kc95] for more analytic results on the value of A.
In summary, this method reduces the number of additions by 3 to 7%, for 128 s 2048, less than the m-ary method.
Variable length nonzero windows This strategy tries to produce nonzero windows whose right-end and left-end bits are both 1.
Two parameters are to be decided: the maximum length d of nonzero windows and the maximum number r of adjacent 0's allowed inside any nonzero window.
This method generally tries to decrease further the average number of nonzero windows when d and r are chosen optimally.
We should choose 4 d 8.
This method requires (2d 2)/2 = 2d1 1 pre-computations (and memory storage), probabilistically about A additions, where A is the number of non-zero windows, A s/d and D doublings.
Refer to KoÃ¯Â¿Â½ [Kc95] for more analytic results on the values of A and D.
In summary, this method reduces the number of additions by 58%, for 128 s 2048, less than the m-ary method.
b. Signed binary window methods These methods transform an ordinary binary expansion B into a signed binary expansion S.
(The transformations are also called "bit recoding" techniques.)
Again, the methods or algorithms using "signed" expansion are much more efficient in implementing elliptic curve operations than in finite field operations since the subtraction is just as costly as addition.
The purpose is to skip a bit string of 1's (in addition to bit strings of 0's, as usual) to reduce the number of additions.
Morain-Olivos' algorithm ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 67 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- This algorithm reduces the weight of the signed binary form S, i.e., the number of non-zero digits, denoted by #1(S).
The idea is that a block of n bits 1 can be replaced by a bit string that is a block consisting of a bit 1 followed by n bits 0 and then minus 1.
That is: 11L1 = 100L 0 - 1 .
This observation is extracted from the equality: 13 1 3 2 2 2n+1 1 = (2n + 2n 1 + ...+21 + 20).
As a result, (n 1) doublings and (n 1) additions (i.e., 2(n 1) total additions) can be replaced by n doublings and 1 subtraction (i.e., (n +1) total additions).
In other words, this method tries to construct two positive integers k+ and kÃ¯Â¿Â½ such that k+ k = k.
The total computation for (k+ k).P is less than that for kP. Note that there are not two separate computations of k+P and kP, but actually the computations merge together: kP only shows up in a few subtractions corresponding to the positions of its bits 1 in the scalar k.
The same idea is to deal with a special string that has isolated 0's.
We observe that: k = 1L1 0 1L1 = 1 0L 0 1 0LL 01 = 1 0L 0 - 00L 0 10LL 01 , where bit 1 denotes {{ {14 { {14 423 423 n bits m bits n bits ( m-1) bits n + m +1 bits n bits ( m-1) bits n bits n bits (1), and we assume m 2.
This observation is extracted from the same equality above, applied twice.
Then we have the formula: kP = 2m.(2n+1.P P) P. That is, an isolated 0 inside a block of bit 1's will contribute only two subtractions/additions and one extra doubling, instead of (n + m 1) additions.
Morain-Olivos [MO90] provides detailed estimations of implementation cost.
In summary, the method reduces about 3% for 100-digit number and 2.7% for 300-digit number.
Jedwab 
The original idea was proposed by Mitchell 
MÃ¯Â¿Â½ller [Mu98] discussed improved versions over Morain-Olivos' method.
A generalization of the Morain-Olivos' algorithm We can generalize this result for k being a string of (b 1) isolated bits 0 sandwiched among b blocks of bits 1, where b is larger than 2, the following can be written: k = 1LL10L1LL10 1LL1 = 1 0LL2LL 0 - 00L 0 1L 0LL 0 10LL 0 1, 13 13 13 2 2 2 14 L44 4 3 { 14 14 423 423 N1 bits N b -1 bits Nb bits N1 +L+ Nb + ( b -1) bits N1 bits N b -1 bits ( Nb -1) bits assuming Nb 2.
This observation is also derived from the above equality: 2n+1 1 = (2n + 2n1 + ...+ 21 + 20).
Then we can obtain the following formula: kP = 2 N b Ã¯Â¿Â½(2 N b-1 +1Ã¯Â¿Â½[L(2 N1 +1Ã¯Â¿Â½P - P)L] - P) - P.
This formula dramatically generalized the application of Morain-Olivos' algorithm such that b can be any positive number greater than 2, rather than being restricted to b = 2 only.
By applying this algorithm, (N1 + ...
+ Nb 1) additions were replaced by only b subtractions/additions and one extra doubling.
The savings in the number of arithmetic operations are significant when the sum (N1 + ...
+ Nb) is much larger than b, which should be obtainable for those cases of k. Koyama-Tsuruoka's algorithm ([KT92]) This algorithm improved the above methods by increasing the average length of zeros in the signed binary expansion using { 1 , 0, 1}, where bit 1 denotes (1).
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 68 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- A binary string of a non-zero window B = (1, bn,..., bi,..., b1, 1) in k will be transformed to a signed binary string of the form T = (1, 0, tn,..., ti,..., t1, 1 ), where ti = bi 1, for all 1 i n.
This transformation is effective (i.e. actually decreases the weight of the bit string) only when the difference between the numbers of bits 1 and bits 0 is: Diff(B) = #1(B) #0(B) 
However, we should keep in mind that the transformation also costs us one extra doubling because of the extra bit.
Both methods (by Koyama-Tsuruoka and Morain-Olivos) generate a signed bit string with the same weight, but the average length of zero runs by the Koyama-Tsuruoka method is greater than that of the Morain-Olivos method.
By this method, one needs to pre-compute only the odd scalar points Ã¯Â¿Â½3P, Ã¯Â¿Â½5P,..., upto Ã¯Â¿Â½(2d 3)P, since this algorithm never allows the points Ã¯Â¿Â½(2d 1)P to appear.
In fact, this transformation is extracted from the equality: 2n+2 2n+1 = 2n+1 = (2n + 2n 1 + ...+21 + 1 + 1).
Using the relationship 1 = bi ti, for all 1 i n, we then have: 2n+2 + (tn2n + tn12n1 + ... + t121 + 1) = 2n+1 + (bn2n + bn12n1 + ... + b121 + 1).
Refer to Koyama 
Note that, the similar idea in the Koyama-Tsuruoka's algorithm was also discussed in KoÃ¯Â¿Â½ [Kc91].
A generalization of Koyama-Tsuruoka's algorithm Instead of applying this algorithm for a non-zero window only, we try to apply for an arbitrary bit string k = (bn,..., b1, b0), where without loss of generality, we may assume bn = 1.
For all 0 i n, let ti = bi 1, then again insert it into the arithmetic identity: 2n+1 = (2n + 2n1 + ... + 21 + 20) + 1, we can obtain the following identity: 2n+1 + (tn2n + tn12n1 + ... + t121) + t020 1) = (bn2n + bn12n1 + ... + b121 + b020).
When b0 = 1, then t0 = 0, this approach will transform k to the string of digits T = (1, tn,..., t1, 1 ), where the last digit 1 = 1.
This is Koyama-Tsuruoka's algorithm for non-zero window B = (bn,..., b1,1).
When b0 = 0, then t0 = 1, this approach will transform k = (bn,..., b1,0), to the string of digits T = (1, tn,..., t1, 2 ), where the last digit 2 = 2.
This last digit does not affect the scalar point multiplication (kÃ¯Â¿Â½P) at all.
In the very last step of a given scalar point multiplication algorithm, we then subtract a double of a point, 2P, instead of the point P itself.
The point 2P is available for free since it is always computed during the process.
If we use other m-ary methods or window methods, the digit 2 obviously is not a concern anyway.
We need only minor changes in pre-computations.
The number of non-zero digits in T is #non-0(T) = 2 + i =1 n ti = 2 + i =1 n bi - 1 = 2 + 1 i n , bi = 0 (1) = 2 + #0(k'), where k' = (bn,..., b1).
Hence this transformation is effective if the condition 2 + #0(k') 
Since #0(k') = #0(k) 1, we can rewrite the condition as: Diff(k) = #1(k) #0(k) 
Hence Koyama-Tsuruoka's algorithm can extend for any bit strings, which satisfy this condition.
Again, the transformation also costs us one extra doubling because of the extra bit.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 69 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Other algorithms/discussions Jedwab 
The original idea was proposed by Mitchell 
MÃ¯Â¿Â½ller [Mu98] discussed improved versions over Morain-Olivos' method.
All algorithms described above are based on sliding window and bit manipulations.
They gave almost the same level of performance.
They are all doing better than a typical m-ary method.
However, no method actually dominates over the other methods yet.
There is no significant difference or breakthrough in the algorithms showed above.
The attractive point again is using "negative" digits (e.g., 1 = 1 and/or 2 = 2) to have the subtractions involved since the cost of subtraction is the same as that of addition in elliptic curve implementation.
Refer to Gollmann, Han 
d. Methods using addition chains/sequences The problem of optimal addition chains is to find the fewest additions needed to compute a positive integer k starting from 1.
It is used to compute kP from P with the fewest elliptic curve additions (originally, to compute the power xk from x with fewest multiplications).
An addition chain [Ai] of k of length L is of the form: 1 = A0 
Note that in an addition chain, k occurs at the very end of the chain, while in an addition sequence, k just needs to occur someplace in the sequence.
For our practical purpose, now we mention only addition chains.
Obviously, there can be many different addition chains for a given positive integer k. Naturally, we are most interested in finding the addition chain of minimum length since it will help to minimize the number of arithmetic operations.
In another version, we call an addition/subtraction chain, when [Ai] satisfies weaker conditions: for 1 i L, Ai = Aj + Am or Ai = Aj Am, where i 
A star chain is an addition chain [Ai] satisfying: for 1 i L, Ai
That is, one summand must be the very previous element.
A star step is called a "simple step" when l = 1.
Refer to Downey, Leong 
Generally, computing the addition chain of minimum length is a very difficult problem, but there are simple algorithms to produce good addition chains, even near minimum length.
The most common algorithm is using the binary form as in double-andadd (or addition-subtraction) method, even though it usually produces addition chain ______________________________________________________________________ __________________ c.
A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 70 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- larger than minimum length.
Finding the addition chain with the minimum length will benefit the algorithms to compute the scalar point multiplication kP, since it will minimize the number of required additions.
Bos 
This method will be significant when sliding window methods of large width are used.
In those cases, the pre-computed table will require a large number of computations and also storage.
We do not even need the addition chain for k. Instead, we need to create only an addition sequence that consists of the needed window numbers only.
These window numbers are of course less than 2w, where w is the window width.
Hence they are much smaller than k itself.
Then using one of the methods discussed previously, we can create the addition chain for k. Yacobi [Y91] proposed a similar method, systematically developing into a heuristic algorithm (that is claimed to be a modification of the Lempel-Ziv data compression algorithm.)
We will apply a 2d-ary method (or sliding window method) where we will pre-compute only those intermediate scalar point multiplications that will be needed.
However, this algorithm is not better than a 2d-ary method for small scalar k, less than 512 bits, but it is more efficient for larger k. Most recently, Aigner 
4.C.3.
Scalar point multiplication: other methods a.
Using projective coordinates Menezes 
It is to remove the inversion operations in point addition or doubling operations in the intermediate steps in any scalar point multiplication algorithm implemented.
At the final step, we can use a single inversion to convert it to affine coordinates as usual.
Menezes 
Koyama 
- - Let P = (x1, y1, 1) and Q = (x2, y2, z2).
We can rewrite Q = ( x2 z2 1 , y2 z2 1 ,1) and apply the regular point addition formulae (for affine coordinates) to find R = P + Q = (x'3, y'3, 1).
Then let z3 be the common denominators of x'3 and y'3, we can write R = (x3, y3, z3).
The completed results for all three usual cases of elliptic curves over finite fields are summarized in the table 4.6.
For convenient reference, we also include the formulae of the additive inverse of a point in the first column.
Equation of elliptic R = (x3, y3, z3) = (x1, y1,1) + (x2, y2, z2) = P + Q curve E over Fq in ---------------------------------------------------------------------- --Let A = x1z2 + x2, B = y1z2 + y2, X = x2 x1z2, Y = y2 y1z2 affine coordinates Over Fp, p 2, 3 if P Ã¯Â¿Â½Q XT 2 3 x3 = y = x + ax + b 2 2 if P = Q, 2 y1 ( S - 8 x1 y1 ) = 16(4a3 + 27b2) ( x y - x y ) X 2 z - YT if P Ã¯Â¿Â½Q 0 y3 = 1 2 22 1 2 2 4 P = (x1, y1, 1) S (12 x1 y1 - S ) - 8 y1 if P = Q , Q = ( x2 , y2 , z2 ) Then ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 71 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Q = (x2, y2, z2) X 3z z3 = 3 8 y1 2 if P Ã¯Â¿Â½Q if P = Q , 2 where T = Y z2 AX 2 and S = 3 x12 + a.
(A slightly revised version of Koyama 
Point addition formulae in the projective coordinates (xz, yz, z) With the above formulae, we can compute the scalar point multiplication, kP = k.(x1, y1, 1) = (x, y, z), by repeated additions, as usual.
Then by a single inversion at the very end step to get z1, we can write kP = (xz1, yzÃ¯Â¿Â½ 1).
The disadvantage of this method is that it requires larger memory to store points of three coordinates on an elliptic curve.
We can develop other scalar point multiplication formulae by using the Jacobian projective coordinates, (z2x, z3y, z) , z 0.
Again, let P = (x1, y1, 1) and Q = (x2, y2, z2).
- - We rewrite Q = ( x2 z 2 2 , y 2 z 2 3 ,1) and apply the regular addition formulae (for affine coordinates) to find R = P + Q = (x'3, y'3, 1).
Then we convert it back to the original Jacobian projective coordinates.
The completed results for all three usual cases of elliptic curves over finite fields are summarized in the table 4.7.
Equation of elliptic R = (x3, y3, z3) = (x1, y1,1) + (x2, y2, z2) = P + Q curve E over Fq in ---------------------------------------------------------------------- -2 3 2 3 affine coordinates Let X = x1 z2 + x2 , Y = y1 z2 + y2 , C = x2 - x1 z2 , D = y2 - y1 z2 Over Fp, p 2, 3 D 2 - XC 2 if P Ã¯Â¿Â½Q 2 3 x3 = 2 y = x + ax + b 2 if P = Q , S - 8 x1 y1 = 16(4a3 + 27b2) 0 P = (x1, y1, 1) Q = ( x2 , y2 , z2 ) ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 72 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Then Q = (x2, y2, z2) 2 3 D ( x1 z3 - x3 ) - y1 z3 y3 = 3 S ( 4 x1 y12 - x3 ) - y1 z3 if P Ã¯Â¿Â½Q Cz2 z3 = if P = Q, 2 y1 if P Ã¯Â¿Â½Q if P = Q , where S = 3x12 + a.
(A slightly revised version of Cohen, Miyaji 
Point addition formulae in the Jacobian projective coordinates (z2x, z3y, z) Refer to Agnew, Mullin 
b. Montgomery's method This method is extracted from a work of Montgomery [M87].
In the table 4.8., we show the relations of the x-coordinates of 2 points (P + Q) and (P Q).
Equation of elliptic curve E over finite field P + Q = (x3, y3) 
Addition formulae using the Montgomery's method Hence, for both supersingular and non-supersingular elliptic curves over binary finite field GF(2m), we can compute the x-coordinate x3 of (P + Q) with only one ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 73 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- inversion and a few finite field additions from the x-coordinates of P, Q and (P Q).
The y-coordinates are not involved in the computations.
However, if over prime finite field Fp, the computation must involve also the ycoordinates y1 and y2.
Hence the Montgomery's method performs better over binary finite fields than over prime finite fields.
To compute point kP, where k = (kr1,..., k0) in base 2, we first compute the point 2P.
Thereafter, given a pair of points (mP, (m + 1)Ã¯Â¿Â½P), we then compute in step i either (2mÃ¯Â¿Â½P, (2m + 1)Ã¯Â¿Â½P) if ki = 0, or ((2m + 1)Ã¯Â¿Â½P, (2m + 2)Ã¯Â¿Â½P) if ki = 1.
The Montgomery's method has a considerably slower speed since in each step (for each bit) we must compute A doubling in order to get the point 2mÃ¯Â¿Â½P or (2m + 2)Ã¯Â¿Â½P = 2(m + 1)Ã¯Â¿Â½P) and A point addition with point (Ã¯Â¿Â½P) to get (2m + 1)Ã¯Â¿Â½P.
On the other hand, these computations also provide one advantage of this method: the ability of resistance against the power differential analyses attacks since there is no distinction on operating over bit 0 or bit 1.
One may even use projective coordinates in the Montgomery's method to reduce the inversion (or division).
We summarize the formulae in the table 4.9.
Equation of elliptic curve E over finite P + Q = (x3, y3, z3) 
Addition formulae using the Montgomery's method in the projective coordinates (xz, yz, z) Hence, over binary finite fields GF(2m), for both supersingular and nonsupersingular elliptic curves, we can compute the x-coordinate x3 of (P + Q) with a few field operations from z2 and x-coordinates of three points P, Q and (P Q).
Over prime finite fields Fp, the computation must involve also the y-coordinates y1 and y2.
Moreover, no inversion or division is required.
We can do similar computations over the Jacobian projective coordinates of the form (z2x, z3y, z) , z 0.
Equation of elliptic curve E over P + Q = (x3, y3, z3) and P Q = (x4, y4, z4), where finite field Fq P = (x1, y1,1), Q = (x2, y2, z2) and P Ã¯Â¿Â½ Q 3 Over Fp, p 2, 3 x3 = x4 4y1y2 z 2 2 3 y = x + ax + b z3 = z4 (and = 16(4a3 + 27b2) 0) ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 74 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------4 Non-supersingular elliptic curve over x3 = x4 + z 2 x 1 x2 m GF(2 ) z3 = z4 y2 + xy = x3 + ax2 + b (and b 0) 6 Supersingular elliptic curve over x3 = x4 + z 2 c 2 m GF(2 ) z3 = z4 y2 + cy = x3 + ax + b (and c 0) Table 4.10.
Addition formulae using the Montgomery's method in the Jacobian projective coordinates (z2x, z3y, z) Again, over binary finite fields GF(2m), for both supersingular and nonsupersingular elliptic curves, we can compute the x-coordinate x3 of (P + Q) with a few field operations from z2 and x-coordinates of three points P, Q and (P Q).
Over prime finite fields Fp, the computation must involve also y-coordinates y1 and y2.
Moreover, no inversion or division is required.
In summary, the Montgomery's method always works better over binary finite fields than over prime finite fields for either affine coordinates or projective coordinates.
c. Demytko's work ([D94]) Let P = (x, y) be a point on an elliptic curve E: y2 = x3 + ax + b over finite field Fp with its discriminant = 16(4a3 + 27b2) 0.
Let Pk = k.P = (xk, yk).
2 ( xk - a) 2 - 8bxk ( xk2 - a) 2 - 8bxk If yk 0 (mod p), then x2k = .
= 2 3 4 yk 4( xk + axk + b) (a - xk xk +1 ) 2 - 4b( xk + xk +1 ) If xk xk+1 and x 0 (mod p), then x2k+1 = . x( xk - xk +1 ) 2 4b + 2(a - xk xk +1 )( xk + xk +1 ) If xk xk+1 and x 0 (mod p), then x2k+1 = + x. ( xk - xk +1 ) 2 We can observe that xk xk+1 (mod p) only when Pk = Pk+1 or (2k + 1)Ã¯Â¿Â½P = O. Recall from the Montgomery's method, we have a more general formula 4b + 2(a - xi x j )( xi + x j ) If xi xj then xi+j = + xij. ( xi - x j ) 2 This yields a chosen message attack proposed by Kaliski [K97].
We can also use the projective coordinates in the above formulae.
For example, we denote P = (X, Y, Z) and Pk = k.P = (Xk, Yk, Zk).
Then we have: X2k = ( X k2 - aZ k2 ) 2 - 8bX k Z k3 ; Z2k = 4Zk ( X k3 + aX k Z k2 + bZ k3 ) and X2k+1 = Z.[(XkXk+1 aZkZk+1)2 4bZkZk+1(XkZk+1 + Xk+1Zk)]; Z2k+1 = X(XkZk+1 Xk+1Zk)2.
d. Direct multiplication formulae and others For practical implementation, the inversion of finite field elements is the most expensive operation to perform in finite fields.
Guajardo 
Instead of repeating doubling P many times to compute the intermediate points 2P, 22P,...,2d1P, which may be of no use at all, we should derive a general direct formulae to compute point (2d.P) for any positive integer d, as large as one can.
In each formula, we try to reduce the number of inversions to a possible minimum.
Those formulae can be applied in the pre-computations of 2d-ary methods or window methods to improve the efficiency.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 75 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Shamir's speed-up algorithm to compute point (aP + bQ) is to go through the non-adjacent signed binary expansions of the scalars a and b at the same time, doubling and adding/subtracting P, Q, and P Ã¯Â¿Â½ Q.
This algorithm is claimed to have fast speed but it also requires more memory.
Others, such as Lee 
Gallant, Lambert 
4.C.4.
Algorithms on composite extension finite fields For a composite extension finite field, we mean a finite field of the form GF(2r), where r is a composite number r = nm.
Then the finite field GF(2mn) is considered an etension field of order m of the subfield GF(2n), (or an extension field of order n of the subfield GF(2m)).
Refer to Green 
Multiplicative inversion over composite extension finite fields Guajardo [G97], Paar [P95]
It takes advantage of calculations in the subfield GF(2n) of small degree n.
The reduction polynomial of GF(2nm) over GF(2n) is P(x).
The inverse of a non-zero element A GF(2nm) is defined by: A1 = (Ar)1Ar1, where r = (2nm 1)/(2n 1) and Ar GF(2n).
First, the term Ar1 will be computed using addition chains since r 1 = 2n + 22n + ... + 2(m1)n. Second, we observe that the product Ar of two elements A and Ar1 in GF(2nm) is, in fact, in the subfield GF(2n).
This helps to reduce the cost in comparison with general multiplication in the composite extension finite field GF(2mn) if we choose the reduction polynomial P(x) carefully.
Third, the inversion (Ar)1 is easily performed in the subfield GF(2n).
The final product between an element (Ar)1 GF(2n) and an element Ar1 GF(2nm) also requires only m multiplications in GF(2n) and no reduction modulo polynomial P(x).
Fan 
The simplest case for the extension field of degree m = 2 was discussed in Kasahara 
Many research articles have already focused on VLSI architectures for fast implementations of arithmetic operations: multiplication, inversion and exponentiation.
Current approaches are combinations of structure of composite extension finite fields and ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 76 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- hardware architectures: bit parallel arithmetic in subfield and serial processing for extension field arithmetic.
This is called the parallel-serial (hybrid) approach.
This could have very fast implementations.
Refer to Paar 
e. Current issues on elliptic curves over composite extension finite fields Consider a non-supersingular elliptic curve over a composite extension finite field GF(2nm) of the equation: E: y2 + xy = x3 + ax2 + b, where coefficients a and b are in the subfield GF(2n).
Then E is referred to as a "subfield elliptic curve".
Particularly, when n = 1, it is just a Koblitz curve or a binary anomalous curve (ABC).
In practice, we prefer the order #E to be prime or divisible by a small number.
Hence we should use GF(2nm) where n is equal to 1 or is small and m is a large prime.
Otherwise, the order #E(GF(2nm)) will have a considerably large factor #E(GF(2n)).
However, there are always concerns about using the elliptic curves over composite extension Galois fields in cryptography by world mathematicians.
Refer to MÃ¯Â¿Â½ller 
There is also current research mentioning general doubts about constructing elliptic curves with special coefficients (such as Koblitz curves and subfield elliptic curves) and/or over finite fields with special internal structure (such as composite extension finite fields).
Gallant, Lambert 
The idea is to partition the group P into equivalence classes using the Frobenius endomorphisms : E(GF(2m)) E(GF(2m)), by: (x, y) = (x2, y2).
We define the equivalence relation ~ by: P1 ~ P2 if and only if P1 = Ã¯Â¿Â½ l(P2), for some l such that 0 l m 1.
Assuming that (P) = (x, y) = Ã¯Â¿Â½(x, y), then the equivalent class of point P includes [P] = {P, P, 2P,..., m1P, P, P, 2P,..., m1P} and [O]
Therefore, the number of elements to be searched is reduced by a factor of 2m; hence the running time that is proportional to the square root of the size of the group, will be reduced by a factor of (2m)1/2.
Wiener 
The running time is also reduced by a factor of (2m)1/2.
4.C.5.
Representing points on an elliptic curve The coordinates x and y of any point (x, y) on an elliptic curve must satisfy the cubic relation.
Hence to represent an elliptic curve point, both coordinates are not required.
Therefore, we can save space in storage of such points.
There are a few methods developed to represent elliptic curve points.
The terminology of such methods is not agreed upon globally yet. a.
Compressing and recovering points on an elliptic curve When p 
The compressing and recovering employs the propert that: the coordinates of two points P and its (additive) inverse point (P) are: P = (x, y) and (P) = (x, y) = (x, p y).
Compressing: Consider a point P = (xP, yP) on E.
Then the compressed form of P consists of xP and the rightmost bit of yP, denoted by P, when yP is written in the binary ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 77 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- expansion form.
In other words, we have P yP (mod 2).
Two values y and (p y) always have the opposite rightmost bits.
Recovering: Given xP and P, we can recover point P or, in fact, yP.
First, we 3 compute the square root r of value ( x P + axP + b) (mod p).
If the rightmost bit of r is equal to P, then yP = r. Otherwise, let yP = p r.
When p = 2, E: y2 + xy = x3 + ax2 + b, a non-supersingular elliptic curve over a finite finite field GF(2m).
For any two points P = (x, y) and P = (x, y + x), the difference between two ratios of point coordinates (yx1) and (y + x) x1 = yx1 + 1 are only 1, i.e., the rightmost bit in binary expansion form.
Observe also that if x 0, we can write the elliptic curve equation in terms of (yx1): (yx1)2 + yx1 = x + a + bx2.
Compressing: The compressed form of a point P = (xP, yP) on E consists of xP and a bit P.
If xP = 0, let P = 0.
(Actually, we do not care nor use this bit).
If xP 0, let P be - the rightmost bit of ( y P x P1 ) .
Recovering: Given xP and P, we can recover yP as follows.
If xP = 0, let yP be the root of b. Particularly, using the identity b 2 = b, we have yP = b 2 .
(We ignore P, or just consider it a check bit).
If xP 0, we need to solve the equation r2 + r = - + bx P2 (mod p) for a root ro. Observe that the other root is (ro + 1).
We choose r = = ro + 1, such that the rightmost bit of r is equal to P.
Then compute yP = xPr.
Compact form for cyclic subgroup of an elliptic curve This form, originally proposed by Seroussi [S98] is applied only for nonsupersingular elliptic curves E: y2 + xy = x3 + ax2 + b, with b 0, over a binary finite field GF(2m).
In fact, it is applied only for a cyclic subgroup of the elliptic curve.
We can rewrite the equation as: z2 + z = x + a + bx 2 where z = y/x, assuming that x 0.
We have some observations.
Given x 0, the above equation of z has a solution if and only if we have Tr (x + a + bx 2) = 0.
Therefore, for any point P = (x, y) E, where its xcoordinate 0, we must have the identity: Tr(x + a + bx2) = 0.
Using the equality: Tr(a + b) = Tr(a) + Tr(b), it can be rewritten as: Tr(x + bx2) + Tr(a) = 0 or Tr(x + bx2) = Tr(a), since values of the trace function Tr(Ã¯Â¿Â½) is in F2.
The point P = (0, y) in fact has order 2.
If Q = (xQ, yQ) = 2P E, then xQ = x2 + bx2.
If P (0, y), then Q is not the point at infinity.
Using the equality on trace function: Tr(x) = Tr(x2) over finite field GF(2m), we can derive the following relations: Tr(xQ) = Tr(x2 + bx2) = Tr(x + bx2) = Tr(a), for any point P whose order is other than 2.
Seroussi used this fact to represent a point on an elliptic curve by "compact form" that needed only m bits, instead of (m + 1) bits as they did in the compressed form, discussed above.
In an elliptic curve cryptosystem, we should always consider points in a cyclic subgroup of large prime order n (hence n is odd).
Any point P = (x, y) in such subgroup cannot have order 2, and there always exists a point R such that P = 2R.
Indeed, we can write explicitly: P = (n + 1)Ã¯Â¿Â½P = 2R, where R = [(n +1)/2]Ã¯Â¿Â½P.
In other words, we always have Tr(xP) = Tr (a), for any point P = (x, y) (0, y) that is used in an elliptic curve cryptosystem.
That is, we can eliminate one bit from the x-coordinate of point P = (x, y) without ambiguity.
The position of this bit can be chosen depending on the basis of the finite fields.
square the bit xP + a ro or r b. m m -1 ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 78 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Combined with the compressed form, we can fill up the removed bit from x by the single bit representing y-coordinate.
Hence this form has exactly m bits to represent a point P = (x, y) in the cyclic subgroup mentioned.
Particularly, we will utilize the matrix implementation of trace function Tr(x) = T.xt, where xt is the transpose matrix of x = (x0, x1,..., xm1) GF(2m) and T is an m Ã¯Â¿Â½ m matrix that depends on the basis used to represent the finite field GF(2m) and is calculated in advance.
Then we will eliminate any i-th position bit of x where the corresponding bit T(i) = 1 in the matrix T.
For recovering, that bit will be determined uniquely to get the relation between x and a: Tr(x) = Tr(a).
This representation is proved to be optimal for points on non-supersingular elliptic curves over finite field GF(2m).
Recall that a non-supersingular elliptic curve has even order and more particularly, #E(GF(2m)) 2Tr(a) (mod 4).
That is, one can write #E(GF(2m)) = 2s, for some value s (or even #E(GF(2m)) = 4s, for the case Tr(a) = 0).
Therefore, the prime order n of the interested cyclic subgroup of the elliptic curve is at most Ã¯Â¿Â½ (or Ã¯Â¿Â½ when Tr(a) = 0) of the curve order #E(GF(2m)) that is at most (2m + 1 + 2.2m/2).
We can even drop the term 1 since the order must be even.
Hence If Tr(a) = 1, then n 2m1 + 2m/2 
Hence, an m-bit form can be sufficient to represent all points in the cyclic subgroup of the elliptic curve.
If Tr(a) = 0, then n 2m2 + 2(m/2)1 
Hence, an (m 1)-bit form is sufficient.
c.
Other discussions The compressing techniques just solve the simple problem of only 1-bit ambiguity of the y-coordinate.
When we use only the x-coordinate, it does not matter how one can determine its corresponding y-coordinate of point P or its inverse point (P).
If we need the y-coordinate, we still can use other conventions without having explicitly the extra bit, from the known facts on the coordinates of point P and point (P) as follows: y(P) = p yP for prime finite fields Fp, p 
One can define y to be the smaller/larger, odd/even or "positive/negative" (in sense of modulo p) of two values upon mutual agreement.
Another approach is to try to use values independent of points (or y-coordinates) such as y2 or yÃ¯Â¿Â½(x + y) in our algorithms.
But this approach could cost us more than 1 bit.
For discussions and algorithms in this approach, refer to Montgomery [M97], Demytko [D94]
Another option that could be employed is to use the full y-coordinate of a point and two bits to represent x-coordinate, since for a given y, there are possibly three values of x from the elliptic curve equation.
However, the security of an elliptic curve cryptosystem does not depend on the representation of a point in either a compressed, non-compressed or compact form.
4.C.6.
Half-point algorithms It is reasonable and practically necessary to find algorithms to compute the half of a point, i.e., (Ã¯Â¿Â½Ã¯Â¿Â½P) of a given point P on an elliptic curve.
In other words, we need to solve the following problem: Given a point P, find another point Q on the same elliptic curve such that 2Q = P.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 79 of 105 NAS Technical Report - NAS-03-012 Au
There is also general doubt that the more special internal structures are embedded in a finite field chosen for an elliptic curve cryptosystem, the more vulnerable this cryptosystem will be.
A Mersenne prime is of the form p = 2t 1, where t is, obviously, a prime.
We call t a Mersenne exponent.
For example, t = 2, 3, 5, 7, 17, 31, 89, 127, 521 and 607, we have (2t 1) to be a Mersenne prime.
A Mersenne number is of the form (2t 1), where t is not necessarily a prime.
Not any prime can be a Mersenne exponent; e.g., 211 1 = 2047 = 23Ã¯Â¿Â½89 is a composite number
.
______________________________________________________________________ __________________ 4.A.
A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 43 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Pseudo Mersenne primes.
In Crandall's patent [C92], the Mersenne primes are a subset of fast class numbers, which are primes of the form p = 2t C, where C is a very small positive number in practice.
They are called pseudo Mersenne primes.
Then the modular reduction (modulo p) can be implemented very efficiently in this case: using only cyclic shifts and additions, with no divisions required.
This advantage is also for the Fermat s primes of the form p = 2 2 + 1.
Generalized Mersenne primes.
Generalized Mersenne primes are also implemented for prime finite fields.
They are primes of the form p = 2n 2s 1.
Modular reduction method.
The binary form of a number a is represented as a = ant -1ant -2 K a( n-1) t L ait +( t -1) K ait +1ait L at -1 K a1a0 = An 1... A1A0.
424 3 1442443 144 44 2 31 t terms t terms t terms where each set of t bits, starting from the far right side, are grouped.
Let p = 2t C.
Then we have: 2t C (mod p).
Hence Ai = (ait+ (t 1)...ait+1ait) = 2 it j =0 t -1 ait + j 2 j C i j =0 t -1 ait + j 2 j (mod p).
That is, to compute Ai (mod p) we just shift its bits to the positions for those of A0, then we compute its decimal value.
Adding them up, we get the modulo p of a a (mod p) An 1 (mod p) + ... + A0 (mod p).
When C = Ã¯Â¿Â½1, the algorithm will have only shiftings and additions/subtractions.
When C Ã¯Â¿Â½1, the algorithm will actually have shiftings, multiplications by C, and then additions/subtractions. b. Finite fields GF(2m) of characteristic 2 (binary finite fields) We now discuss more on the bases of GF(2m) that is considered a vector space of dimension m over F2.
A basis is a set of elements {e0, e1,..., em1} in GF(2m) such that each element a GF(2m) can be represented uniquely by the form a = i =0 m -1 ai ei , where ai F2, i.e., ai = 0 or 1.
Then one can write: a = (a0, a1,..., am 1).
There are many different bases of GF(2m).
The most natural bases are, of course, polynomial bases, normal bases and optimal normal bases.
c. Extension finite fields Extension finite fields are special cases of practical implementation.
They are divided into two groups: composite finite fields of characteristic 2 are of the form GF(2n)m) and Optimal Extension Fields (OEF) of the form GF(2n Ã¯Â¿Â½ c)m) have characteristic greater than 2.
We can summarize all types of finite fields, which are currently implemented, into the table 4.1.
Finite Fields Prime finite fields GF(p), p 
Finite field classifications 4.A.2.
Polynomial bases ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 44 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Let f(x) = xm + fm1 xm1 + ... + f1x + f0, where fi F2, be an irreducible polynomial of degree m over F2.
We call f(x) the reduction polynomial (or sometimes, field polynomial).
Let = x + (f(x)) be a root of f(x).
Hence the set {m1,...,2, , 1} is a polynomial basis, where i= xi + (f(x)), for 0 i m 1.
Then the elements of the finite field GF(2m) can be represented as the set of all polynomials of degree 0 d m 1: a(x) = am 1 xm 1 + ... + a1x + a0, where ai = 0 or 1.
One can also write: a(x) = (am1,..., a1, a0).
Particularly, we can write the zero element 0 = (0, 0,..., 0) and the multiplicative identity 1 = (0, 0,..., 1). a.
Irreducible polynomials A polynomial f(x) is called irreducible if we cannot write f(x) = g(x).h(x), for any polynomials g(x), h(x) of degree strictly less than the degree of f(x).
An irreducible polynomial f(x) = xm + fm 1 xm 1 + ... + f1x + f0 of degree m over F2 should satisfy these necessary conditions: The constant term f0 = 1; otherwise, we can factor x out.
Hence from now on, we always write the general form as: f(x) = xm + fm 1 xm 1 + ... + f1x + 1.
There is an odd number ( 3) of nonzero terms; otherwise, f(x) whose number of nonzero terms is even has a factor (x + 1).
There must be at least one term of odd degree; otherwise, f(x) of all even powers is a square of a polynomial of degree (m/2).
It is easy to verify this property: If f(x) = xm + fm 1 xm 1 + ... + f1x + 1 is an irreducible polynomial of degree m, then so are polynomials g(x) = f(x + 1) and h(x) = xm.f(1/x) = xm + f1 xm 1 + ... + fm 1x + 1.
The compositions of g(x) and h(x) will give us a few more irreducible polynomials.
b. Primitive polynomials If f(x) = fm xm + ... + f1x + f0 is an irreducible polynomial of degree m over F2 and r is a root of f(x) in an extension field of F2 (that is a finite field GF(2m)), then r, r2, r 2 ,..., r 2 are all roots of f(x).
Indeed, if f(r) = 0, then for any d, we have f since fi equals either 0 or 1.
Hence: d d d d d 2 m -1 2d i = f i, f (r 2 ) = f m-1r 2 .( m-1) + L + f1r 2 + f o = ( f m-1r m-1 + L + f1r + f o ) 2 = ( f (r )) 2 = 0.
Property: All the roots of the polynomial f(x) have the same multiplicative order, that is called the period (or order) of the function f(x).
PROOF: Indeed, if order of r is k, i.e., rk = 1, then k| (2m 1).
Hence k is odd.
We also have r r 2 d .l k .2 d = (r 2 ) k = 1.
Therefore, the order of r d 2d is some integer l such that: l | k and = 1.
Hence, k| (2dl).
Since k is odd, we have k | l.
Hence k = l. q.e.d.
The period (or order) of a polynomial f(x) can also be defined as the least positive integer e such that f(x) divides the polynomial (xe + 1).
Definition: If the period of f(x) is (2m 1), that is the order of the multiplicative subgroup GF(2m)* = GF(2m)\{0}, then f(x) is called a primitive polynomial.
All roots of a primitive polynomial f(x) are primitive elements of GF(2m).
For example, the polynomial h(x) = xm + ... + x + 1 divides (xm+1 + 1).
Hence its period is equal to (m + 1) or less and h(x) is not a primitive polynomial of GF(2m), unless m = 2.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 45 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- A primitive polynomial can be built from a primitive element a of a finite field GF(2m) by the formula: f(x) = (x + a)(x + a2) ( x + a 2 ) L ( x + a 2n 2 2m -1 ).
2 2m -1 If another primitive polynomial g(x) = (x + b)(x + b2) ( x + b 2 ) L ( x + b ) is built from a primitive element b, such that b { a | 0 n m 1}, then g(x) f(x).
In other words, each primitive element is a root of only one primitive polynomial of GF(2m).
In fact, the set of roots of all primitive polynomials for a finite field are exactly all primitive elements in GF(2m)* = GF(2m)\{0}.
Hence there can be many primitive polynomials for a finite field GF(2m), when m 3.
And in fact, a primitive polynomial cannot be reducible over F2.
Recall that the number of non-zero terms for a reduction polynomial must be odd.
Hence the first polynomials to be considered are of 3 non-zero terms since we prefer the fewest terms in reduction polynomials.
But irreducible trinomials are relatively sparse; hence the next candidates are polynomials of 5 non-zero terms or pentanomials.
In practice, the most-used polynomial bases are trinomial and pentanomial bases.
We can choose such a reduction polynomial f(x) such that the computations modulo f(x) can be performed efficiently in software and hardware implementations. c. Trinomial basis representation Its reduction polynomial is an irreducible trinomial of the form Tm,k(x) = xm + xk + 1, where 1 k m 1.
In fact, a trinomial Tm,k(x) = xm + xk + 1 is irreducible if and only if its reciprocal trinomial Tm,mk(x) = xm + xmk + 1 is irreducible.
Hence, we should be interested in trinomials of the following form only: Tm,k(x) = xm + xk + 1, where 1 k m/2.
Such trinomials exist for certain values of m only.
If they exist, we should choose the reduction polynomial with the smallest k. Such a trinomial generally will have the most efficient implementation.
d. Pentanomial basis representation Its reduction polynomial is an irreducible pentanomial of the form P(x) = x m + x k3 + x k2 + x k1 + 1 , where 1 k1 
Such pentanomials always exist for m 4.
In practice, it was recommended to use pentanomials whose coefficient triples (k1, k2, k3) or (k3, k2, k1) will have the first coefficient as small as possible and next coefficients are kept as small as possible after fixing the previous one or ones in the triple order.
These polynomials would have more efficient computations of finite field operations.
e.
The field arithmetic Its operations are performed via modulo f(x) over the finite field F2 as follows: The reduction modulo f(x) of a polynomial g(x) is just the remainder when g(x) is divided by f(x).
Field addition is performed component-wise by XOR-ing.
Number theory tip Number of primitive polynomials There are a total of (2m 1) primitive elements in the multiplicative subgroup GF(2m)* = GF(2m) \{0}.
Property: For any integer m 
Hence the number of primitive polynomials of a finite field GF(2m) is equal to (2m 1)/m.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 46 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- (am1,..., a1, a0) + (bm1,..., b1, b0) = (cm1,..., c1, c0) where ci = ai bi.
Field multiplication: (am1,..., a1, a0) Ã¯Â¿Â½ (bm1,..., b1, b0) = (rmÃ¯Â¿Â½ 1,..., r1, r0), where the polynomial (rm 1xm1 + ...+ r1x + r0) is the remainder when the product (am 1xm1 + ...+ a1x + a0) Ã¯Â¿Â½ (bm 1xm1 + ...+ b1x + b0) is divided by f(x) over F2.
Refer also to SchÃ¯Â¿Â½nhage [S77] and Pincin [P89]
Kim, E. J. Lee 
Squaring.
In particular, the squaring operation of a polynomial (am 1xm1 + ...+ a1x + a0) that is performed in modulo 2 is in fact a linear operation; that is, (am 1xm1 + ...+ a1x + a0)2 = am 1x2(m1) + am 2x2(m2) + ...+ a1x2 + a0.
In terms of bit strings, we write: (am1,..., a1, a0)2 = (a2(m1), 0, a2(m2), 0,..., 0, a1, 0, a0).
Then we reduce the resulting polynomial by modulo f(x).
We should refer to some algorithms using squaring matrices when we need to implement many squaring operations in a fixed polynomial basis.
Orlando 
Let L = m/2 and K = m/2, then (am 1xm1 + ...+ a1x + a0)2 = am 1x2(m1) + am 2x2(m2) + ...+ a1x2 + a0.
= x2L[aL+(K1)x2(K1) + aL+(L2)x2(L2) ... +aL+1x2 + aL] + [aL1x2(L1) + ... + a1x2 + a0]
= A.B + C, where A = x2L mod f(x) is a constant depending only on the field representation and A could be reduced to a polynomial of degree much less than m and B = aL+(K1)x2(K1) + aL+(LÃ¯Â¿Â½ 2)x2(L2) ... +aL+1x2 + aL and C = aL1x2(L1) + ... + a1x2 + a0.
Inversion: We need to discuss also some methods of computing the inverse of a non-zero element.
This operation obviously has an important role in field arithmetic.
The general method is using this identity: a1 = a 2 -2 = (a 2 -1 ) 2 , a 0.
Recall that: a 2 -1 = 1.
In implementations, we can even analyze further the power exponent (2m1 1) of a to reduce our computation to a few multiplications.
Another well-known method is using the Euclidean algorithm.
After finding gcd(f(x), a(x)), we can work backward the steps in the Euclidean algorithm to represent gcd(f(x), a(x)), as a linear combination of f(x) and a(x).
This is called the extended Euclidean algorithm: finding polynomials u(x) and v(x) such that gcd(f(x), a(x)) = f(x)Ã¯Â¿Â½u(x) + a(x) Ã¯Â¿Â½v(x).
When gcd (f(x), a(x)) = 1, we can write 1 a(x)Ã¯Â¿Â½v(x) (mod f(x)).
In other words, the polynomial v(x) is the inverse of a(x), modulo f(x).
The explicit algorithm and its hardware architecture can be found easily in computer engineering literature.
In fact, it is generally referred to as an algorithm to compute the ratio b(x)/a(x).
Hence inversion is only a special case when we let b(x) = 1.
Quite a few methods are mentioned in cryptography literature.
For each particular finite field and its chosen reduction polynomial, one method can be implemented more efficiently or conveniently than others.
O'Malley, Orman, Schroeppel 
In fact, this is the only irreducible trinomial of GF(2155) (if one ignores ______________________________________________________________________ __________________ m m -1 m A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 47 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- its reciprocal trinomial) and it is not a primitive polynomial.
The authors developed the "Almost Inverse" algorithm from Elwyn R. Berlekamp's idea (in his book (Algebraic coding theory, 1968)) and the low-end GCD algorithm, which were independently discovered by Silver 
The idea of "Almost inverse" algorithm is to compute the almost inverse of a polynomial a(x) modulo f(x).
It will compute a polynomial b(x) and an integer j (which is less than twice the degree of f(x),) such that a(x) b(x) x j (mod f(x)).
Then the inverse of the polynomial a(x) will be the polynomial b(x) divided by the term xj.
They also suggested a few similarly well-behavior irreducible trinomials: x127 + x63 + 1, x140 + x65 + 1, x182 + x81 + 1, x191 + x71 + 1, x223 + x91 + 1 and x255 + x82 + 1.
Irreducible trinomials are rather sparse.
For finite fields of degrees between 100 to 199, there are 43 fields having no irreducible trinomials.
4.A.3.
Normal bases and optimal normal bases Normal bases are not special only for finite fields of characteristic 2.
In fact, they are defined for any finite field GF(qm) where q is a prime power.
A normal basis of GF(2m) over F2 is a basis of the form {, 2, 2 ,..., 2 }, where GF(2m).
Such a basis always exists.
Then a = (a0, a1,..., am1) will represent the element a = a0 + a1 2 + a2 2 + L + am-1 2 .
By convention, the ordering of bits in normal basis representation is different from that in polynomial basis representation.
Particularly, we can write the zero element 0 = (0,0,...,0) and multiplicative identity 1 = (1,1,...,1).
The most important property of a normal basis is that the square of a field element can be computed easily and implemented efficiently on hardware by just a right 1-cyclic shift on the register.
Indeed, given an element a = (a0, a1,..., am1) represented in a normal m -1 m -1 i i +1 i m-1 basis, we have: a = ai 2 = ai 2 = ai -1 2 = (am1, a0, a1,..., am2).
Then i =0 i =0 i =0 s for any integer s, 1 s m 1, the 2 -th power of element a can be computed quickly by 2 2 2 m -1 m -1 2 an right s-cyclic shift.
That is, a 2 = (ams, ams+1, ..., a0, a1,..., ams1).
We can verify again the relationship: a 2 = a.
Similarly, the square root of a can be computed simply by a left 1-cyclic shift: a1/2 = (a1, a2,..., am1, a0).
Unfortunately, multiplication in a normal basis is more complicated.
a.
The field arithmetic Field addition is performed component-wise by XOR-ing as on a polynomial basis.
Field multiplication: (a0, a1,..., am1) Ã¯Â¿Â½ (b0, b1,..., bm1) = (c0, c1,..., cm1), where ck, for 0 k m 1, is computed by as follows.
First, we have that equality written as: m s k =0 m -1 ck 2k = i =0 j =0 m -1 m -1 aib j 2 Ã¯Â¿Â½ i 2j .
We will compute the products 2 Ã¯Â¿Â½ i 2j = k =0 m -1 (i ,kj) 2 , for k all 1 i, j m 1, where have: ck = that: (k ) i, j (k ) i, j = 0 or 1.
Replacing them back in the previous equality, we i =0 j = 0 (0) i -k , j -k m -1 m -1 ai b j (k ) i, j , where the addition on subscripts are of modulo m. Observe = .
Then we can rewrite (after we dropped the superscript in (i ,0j) ): Page 48 of 105 ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- ck = i =0 j = 0 m -1 m -1 ai b j ( 0) i -k , j -k = i = 0 j =0 m -1 m -1 ai + k b j + k (i0j) = , i =0 j =0 k m -1 m -1 ai + k b j + k i, j Hence we need only the first term in the expansion of the product 2 Ã¯Â¿Â½ i 2j = i , j + k =1 m -1 (i ,kj) 2 .
This formula for ck is very helpful in hardware implementation.
Indeed, each term ck can be obtained from the term c0 by the same hardware setup and a left k-cyclic shift of the involved variables; that is, adding k to each subscript in the formula for c0.
In other words, (a0, a1,..., am) and (b0, b1,..., bm) are replaced by (ak, ak+1,..., am, a0, a1,..., ak 1) and (bk, bk+1,..., bm, b0, b1,..., bk 1) , respectively.
The complexity m of a normal basis is the number of non-zero terms i,j.
Then we have 2m 1 m m2.
When m = 2m 1, the normal basis is an optimal normal basis that will be discussed next.
It is the case that 0,j = 1 for precisely one j, 0 j m 1 and that for each i, 0 i m 1, i,j = 1 for precisely two distinct values j, 0 j m 1.
This is the most important and popular normal basis used in cryptography.
Inversion: One of the most obvious ways (and also efficient in some setups) is to convert to an inversion on a more familiar polynomial basis representation by a basischange matrix multiplication and convert the result back to the original normal basis to display.
Deutsch, Omura, Reed, Shao, Truong 
Then the Hence, a1 = s =0 2s = s =1 m -1 2s . =a m -1 s 2 s =1 = s =1 m -1 a 2 , where we already knew how to compute efficiently each term s a .
Considering that (m 1) cyclic shift operations are of no cost, we still need (m 2) multiplications in the finite field GF(2m) for the final product.
This method is impractical for large m.
The most efficient algorithm was proposed by Itoh 
They exploited a factorization of the exponent (2m 2) into interweaved cyclic shifts (i.e., squares) and multiplications.
We can write: 2m 2 = 2 (2m ( m -1) / 2 - 1)(2( m -1) / 2 + 1) if m is odd, (2 1 1), where 2m1 1 = ( m - 2 ) / 2 .
Hence, for m odd, 2(2 - 1)(2( m - 2 ) / 2 + 1) + 1 if m is even we can compute 2 m -1 -1 2s from 2 ( m -1)/ 2 -1 with a right [(m 1)/2]-cyclic shift and one m -1 ( m - 2 )/ 2 -1 multiplication.
For m even, we can compute 2 -1 from 2 with a total of (m/2) right 1-cyclic shifts and two multiplications.
It can reduce the computation to exactly log2(m 1) + H(m 1) 1 2log2(m 1) multiplications and (m 1) cyclic shifts, where H(m) is the Hamming weight of the binary representation of m. We can check this formula by induction.
However, this method requires storage for intermediate results.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 49 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- A similar algorithm was proposed independently by Vanstone in a lecture at NTT (Nippon Telegraph and Telephone, Japan) in 1987, and it can also be applied to a general power operation.
Another method for inversion, described in Agnew, Beth, Mullin 
If m 1 = gh, then we have 1 = and we used the identity: ah 1 = (a 1) denote 2 ( 2 m -1 -1) = 2 gh -1 = h -1 gi g ( 2 -1) 2 i =0 , where = 2 i =0 h -1 a i , where a = 2g, for the exponent of .
Let i =0 h -1 2 gi = T .
Then we can compute two factors: 2 g -1 ( i) = = 20 + 21 +L+ 2 g -1 = i =0 g -1 2i in (g 1) multiplications (together with (g 1) right 1-cyclic shifts) and (ii) T = i =0 h -1 2 gi in (h 1) multiplications and (h 1)g right 1-cyclic shifts.
Hence, in total, we can compute the inverse 1 of in (g + h 2) multiplications and in hg 1 = m 2 right 1-cyclic shifts.
This number is minimized when both g and h are about (m 1)1/2. b. Miscellaneous implementations Trace of an element: Given a point a = (a0, a1,..., am1) in a normal basis representation, its trace will be easily computed as: Tr(a) = a0 a1 ... am 1.
Indeed, from the squaring formula discussed above, we have Tr(a) = a + a 2 + a 2 + L + a 2 = (a0, a1,..., am 1) + (am 1, a1,..., am 2) + ... + (a2, a3,..., a1) + (a1, a2,..., a0) = (x, x,..., x), where x = a0 a1 ... am 1.
We observe: Tr(a) = 0 if x = 0 and Tr(a) = 1 if x = 1.
Hence Tr(a) = a0 a1 ... am 1.
Therefore, the trace function is also a parity function that indicates whether the number of bits 1 is odd or even.
Furthermore, since squaring and square root operations are just cyclic shifts, we have a trivial proof for the identity: Tr(a) = Tr(a2) = Tr(a1/2).
Finding the roots of equation x2 + x + b = 0: We can observe again that since Tr(x + x2) = 0, the equation has solutions only when Tr(b) = 0.
In that case, one root is x, then the other root is (x + 1), since (x + 1)2 + (x + 1) = x2 + 1 + x + 1 = x2 + x.
In normal basis representation, the roots can be found easily by bit operations.
Indeed, we can write x = (x0, x1,..., xm1) and x2 = (xm1, x0, x1,..., xm2).
Hence the equation is: x2 + x = (x0 xm 1, x1 x0,..., xm 1 xm 2) = (b0, b1,..., bm 1) = b.
Then one can choose xm1 = 0 to compute other bits of a root x = (x0, x1,..., xm1).
The other root is for xm1 = 1.
Then we have: x0 = b0 xm 1, x1 = b1 x0, x2 = b2 x1, ..., xm 2 = bm 2 xm 3.
More generally, we can solve the equation x2 + ax + b = 0, where a is an invertible element, by transferring it to the form X2 + X + a 2b = 0, where X = a 1x.
1 2 m -1 ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 50 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Discrete exponentiation: The goal is to compute the power an GF(2m) where n is its binary form n = (ns1,..., n1, n0) = i =0 s -1 ni 2i .
In a regular way, we then write: an = we get terms a 2i i =0 s -1 a ni 2 i = i =0 s -1 (a 2 ) i .
Using normal basis, in s -1 simply by cyclic shifts.
Thus we need only a number of ni 1 i =0 multiplications or probabilistically about (r/2) multiplications.
Following the 2d-ary expansion method, we may pad an extra number of bit 0's to the left side of the bit string to make s = dr for some integer r.
Then we have n of the form n = (Nr1,..., N1, N0), where each Ni is a d-bit string and Nr1 (0...0).
Explicitly, we can write: n = j =0 r -1 Nj2 dj and Nj = i =0 d -1 n jd +i 2i .
Let wj be the value of the d-bit string Nj.
The idea is to rewrite n as a sum over wj, the values of the d-bit strings Ni.
We have: 1 2d -1 r -1 2d -1 d s j ,w 2 dj w = W ( w) w , where sj,w = 1 if wj = w wj 2 1, for any j. Then n = w=1 j =0 w=1 and sj,w = 0 if otherwise.
Hence a = n (a w=1 2d -1 W ( w) w ) , where W(w) = j =0 r -1 s j ,w 2 dj .
For a randomly chosen n, the term W(w) will have about (r/2d) non-zero terms in it.
In a normal basis, aW(w) will be computed in (r/2d) 1 multiplications.
Then computing the term (aW(w))w will need probabilistically about (d/2) 1 multiplications.
We need to compute all (2d 1) such terms (aW(w))w; and it is possible to use (2d 1) microprocessors in parallel.
Finally, (2d 2) multiplications will provide the final value of an.
Refer to Agnew, Beth, Mullin 
Other works were proposed by Cohen, Miyaji 
4.A.4.
Optimal normal bases (ONB) (Gao 
Existence of ONBs An optimal normal basis over F2 only exists in finite field GF(2m) for certain values of m. Recall from the previous section, when the complexity m of a normal basis (i.e., the number of non-zero terms i,j) is equal to (2m 1), then the normal basis is called an optimal normal basis.
There are two types of ONB, type I and type II, depending on m and hence on the mathematical formulae defining them.
Theorem (Mullin, Onyszchuk, Vanstone 
(Type I ONB). (ii) If (2m + 1) is a prime and 2 is a primitive element in the finite field F2m+1, then the finite field GF(2m) has an optimal normal basis.
(Type II ONB). (iii) If (2m + 1) is a prime such that 2m + 1 3(mod 4), and 2 generates the quadratic residues in the finite field F2m+1, then the finite field GF(2m) has an optimal normal basis.
(Type II ONB).
The converse of the last two statements is also true.
Namely, ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 51 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- f ( 2 ) = ( f ( ) ) = 0.
Hence all elements in the normal basis are exactly all roots of f(x), that is now also called normal polynomial.
i 2i If the finite field GF(2m) has a Type II optimal normal basis, then (2m + 1) is a prime and either 2 is a primitive element in the finite field F2m+1, or 2m + 1 3(mod 4) and 2 generates the quadratic residues in the finite field F2m+1.
(It is useful to observe that 2m + 1 3(mod 4) if and only if m is odd.)
All ONB's of Type I or II are obtainable by the three statements in the above theorem.
The conjecture is that: If m does not satisfy the criteria in the above three statements, then the finite field GF(2m) does not contain an optimal normal basis.
In a later section, we will discuss other low-complexity normal bases, where m 
For a more explicit and practical approach to establish algorithms for ONB, we consider further analyses on m required by the above theorem.
Statement (i): Let s = m + 1.
Recall that 2 is not primitive in Fs, for prime s satisfying s Ã¯Â¿Â½1(mod 8).
Hence we are interested in case of prime s 3 or 5 (mod 8) only when checking the existence of Type I ONB.
When m 2 or 4 (mod 8) and s = m + 1 is prime: Type I ONB exists if and only if ords(2) = s 1 = m.
This case is proved in a more general finite field GF(pm) for any prime p.
The requirement, that s = m + 1 is prime, causes quite a few finite fields having no ONB of type I, such as when m is odd.
The last two statements depend on whether 2 is primitive (hence, not a quadratic residue) in Fp or not primitive.
Statement (ii): Let s = 2m + 1.
We consider the cases that 2 is primitive in Fs, i.e., when s 3 or 5 (mod 8), or, equivalently, m 1 or 2 (mod 4).
When m 1 or 2 (mod 4) and s = 2m + 1 is prime: Type II ONB exists if and only if we have: ords(2) = s 1 = 2m.
Observe that if ords(2) = s 1, then 22m 1 mod(2m + 1), or (2m + 1) | (22m 1).
The finite field GF(22m) contains a primitive (2m + 1)th root of unity, called .
It generates an optimal normal basis of GF(22m) over F2.
Moreover, let = + 1 GF(2m).
Then will generate an optimal normal basis of GF(2m) over F2.
Statement (iii): Let s = 2m + 1.
We consider the cases that 2 is a quadratic residue in the finite field Fs, i.e., when s Ã¯Â¿Â½1 (mod 8).
We need also s 3 (mod 4).
Hence m 3 (mod 4) is the only case to be considered.
When m 3 (mod 4) and s = 2m + 1 is prime: Type II ONB exists if and only if ords(2) = (s 1)/2 = m. Observe that if ords(2) = (s 1)/2, then 2m 1 mod(2m + 1), or (2m + 1)| (2m 1).
The finite field GF(2m) contains a primitive (2m + 1)th root of unity, called .
It generates an optimal normal basis of GF(2m) over F2. b. Structure of ONBs (Ash, Blake 
Let be a primitive (m +1)th root of unity in GF(2m).
Then generates the Type I ONB.
Since m+1 1 = 0 and 1, therefore m + m1 +... + + 1 = f() = 0.
Hence is a root of the reduction polynomial.
We also have ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 52 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Property: There exists an integer ki such that 1 ki m 1, such that Ã¯Â¿Â½ 2 = 2 , with the exception of one value of i such that 1 i m 1.
Type II ONB uses the reduction (normal) polynomial f(x) = fm(x), where all polynomials fi(x) of degree i are computed by the recursive formulae (modulo 2) for all 0 i m: f0(x) = 1, f1(x) = x + 1 and fi+1(x) = x fi(x) + fi1(x), (mod 2), for i 1.
Let be a primitive (2m + 1)th root of unity in GF(22m).
Then = + 1 generates the ONB for GF(2m).
This idea is also used to create other low complexity normal bases.
When m 3 (mod 4), is in fact in GF(2m).
Thus = can generate the ONB for GF(2m).
Property: There are integers ki and mi such that 1 ki, mi m 1, such that i i k = 2 + 2 , for any i such that 1 i m 1.
Note that the generator for the ONB of a finite field is not necessarily a generator for non-zero elements of the finite field itself.
Uniqueness: For every binary finite field GF(2m), there is at most one ONB of each type.
Normal bases for a finite field GF(pm) where p is an odd prime i .
2i k mi A normal basis of GF(pm) is a basis of the form {, p, p ,..., p }, where GF(pm).
Such a basis always exists.
Then a = (a0, a1,..., am 1) will represent the element a = a0 + a1 p + a2 p + L + am -1 p .
Particularly, we can write the zero element 0 = (0, 0,..., 0) and multiplicative identity element 1 = (1,1,...,1).
Given a point a = (a0, a1,..., am 1) represented in a normal basis, we have: m -1 m -1 i i +1 i m-1 a = ai p = aip p = ai -1 p = (am 1, a0, a1,..., am 2) i =0 i =0 i =0 Theorem (Mullin, Onyszchuk, Vanstone 
If the m nonunit roots of unity are linearly independent, then GF(pm) contains an optimal normal basis.
p 2 m -1 2 m -1 p One can write {, p, p ,..., p }, where is a primitive (m + 1)th root of unity.
The elements of the set are called conjugates of .
In other words, we now state: The finite field GF(pm) contains an optimal normal basis consisting of m non-unit (m + 1)th roots of unity if and only if (m + 1) is a prime and p is primitive in the finite field Fm+1.
Here is a sketch of the proof.
If (m + 1) is prime then p(m+1)1 1 mod(m + 1).
That is, (m + 1) | (pm 1), where (pm 1) is the order of the multiplicative subgroup GF(pm)*.
Then the finite field GF(pm) contains a primitive (m + 1)th root of unity.
Since p is primitive in Zm+1, the minimal polynomial of is (xm+1 1)/(x 1) and the non-unit (m + 1)th roots are linearly independent.
Hence the finite field GF(pm) contains an optimal normal basis generated by element .
If finite field GF(pm) contains an optimal normal basis consisting of m non-unit (m + 1)th roots of unity, then (m + 1) must be prime.
Hence we have: p(m+1)1 1 mod(m + 1), or pm 1 mod(m + 1).
2 m -1 Number theory tip Primitive elements of a finite field Page 53 of 105 ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- 4.A.5.
Low-complexity normal bases for GF(2m) (or Gaussian normal bases) (Ash, Blake 
When the optimal normal basis does not exist, we could use the low-complexity normal basis (or Gaussian normal basis,) where m 
The ideas of Ash, Blake 
For a finite field GF(2m), we find a small integer k such that (km + 1) is a prime.
Under certain conditions, there will exist some element GF(2km), 1 and km+1 = 1.
We will try to apply on a trace-like operator from the finite field GF(2km) to GF(2m) in order to find a generator for a low complexity normal basis of GF(2m).
(In case of Type II ONB, we have k = 2 and the operator is = + 1.)
When m is not divisible by 8, one can use the Gaussian cyclotomic periods to construct easily an efficient normal basis for GF(2m).
We summarize the results into this theorem.
Theorem: Given a type T, that is a positive integer, suppose m is not divisible by 8, and p = Tm +1 is a prime.
Let k = ordp(2), and h = Tm/k = (p 1)/k.
The finite field GF(2m) has a normal basis of type T if and only if gcd(h, m) = 1.
When T = 1 or 2, it is type I ONB or type II ONB, respectively, which were discussed previously.
They are the most popular normal bases that are the most efficient multiplications in finite fields.
When T 3, it is called a low-complexity normal base of type T (or Type T Gaussian normal basis.)
If both type I and II ONBs do not exist, then the type T Gaussian normal basis of the smallest T should be used.
Uniqueness: For any positive integer T, every binary finite field GF(2m) has at most one Type T Gaussian normal basis.
Recursive formula for reduction polynomial Let u be an integer of order T modulo p: ordp(u) = T.
For 1 i m, let us define Zi(z) = z 2 (mod p ) + z 2 .u (mod p ) + z 2 .u (mod p ) + L + z 2 .u (mod p ) .
Let f0(t,z) = 1, Z(z) = zp1 + zp2 + ... + z + 1, and fi(t, z) = (t + Zi(z)) fi1(t, z) mod Z(z).
Then the reduction polynomial for the normal basis is: f(t) = fm(t, z).
A primitive element of a finite field Fq is an element such that its order is (q 1) and every non-zero element of Fq is a power of .
Thus, a primitive element is a generator of the multiplicative subgroup GF(q)*.
Let q be an integer 2.
If there is some integer a 
Thus, q is a prime if and only if there is an element of order exactly (q 1) (modulo q).
There are exactly (p 1) primitive elements in the prime finite field Fp, where denotes the Euler's -function.
Primitive elements 
Hence x(p1)/2 = yp 1 = 1.
Therefore, x cannot be primitive.
In other words, If x is primitive, then x is not a quadratic residue.
In particular, the quadratic residues in Fp are of the form x2n and the quadratic non-residues are of the form x2n+1. i -1 i -1 i -1 2 i -1 T -1 ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 54 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Note that we can write (z 1)Z(z) = zp 1.
Hence the modulo Z(z) can be performed simply by: zp 1 mod Z(z), zp+1 z mod Z(z), and generally, zp+j zj mod Z(z).
More calculations for other small finite fields GF(2m) are given in the table 4.2.
as illustrated examples.
Computing polynomials for ONB Type II of finite field Existence of m m GF(2 ) Type I 
Computing reduction polynomials for some ONB Type II's 4.A.6.
Self-dual bases and self-dual normal bases a.
Dual bases Two bases B = {b0, b1,..., bm1} and C = {c0, c1,..., cm1} of a finite field GF(pm) over Fp are called dual bases (or complementary bases) if and only if Tr(ci.bj) = ij, where ij = 0 if i j and ij = 1 if i = j.
The symbol ij is called the Kronecker delta function.
Fact: Every basis has a unique dual basis.
Let s = s0b0 + s1b1 + ... + sm1bm1 and t = t0c0 + t1c1 + ... + tm1cm1.
Then the trace of the product (s.t) is defined by: Tr(st) = s0t0 + s1t1 + ... + sm1tm1, and is used to define a non-degenerate symmetric bilinear form: s, t = Tr(st), which is called the trace bilinear form.
Theorem: Every element a GF(qm) can be expressed in the dual basis C as: a = i =0 m -1 Tr (abi )ci .
The above fact still true in general, when the trace function Tr(Ã¯Â¿Â½) is replaced by any nontrivial linear function f (or transformation) from the finite field GF(pm) to the finite field Fp. Dual bases have many advantages in hardware designs but they are more complex in software implementations, such as field squaring.
Current works using specially designed dual bases were discussed in literature such as circular dual bases and optimal dual bases.
b. Optimal dual bases Benaissa, Fenn 
The authors showed that any linear function g can be of the form ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 55 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- g(z) = Tr(bz), z GF(2m), for some element b GF(2m).
Hence they can choose an optimal element b such that the elements of the resulting dual basis are just a permutation of elements in the given polynomial basis.
c. Circular dual bases Lee 
This polynomial basis is the Type I ONB.
In fact, this circular basis exist only in the finite fields, which have Type I ONB.
Explicitly, if the polynomial basis (or Type I ONB) is {1, , 2,..., m 1}, then its circular dual basis is {1, c, c2,..., cm 1}, where ci = + i, for 1 i m 1.
A short list of degree m of such finite fields are: m = 4, 10, 12, 18, 28, 36, 52, 58, 66, 82, 100, 106, 130, 138, 148, 162, 172, 178, 180, 196, 210, 226, 268, 292, 316, 346, 348...
The authors showed a few advantages and efficiencies of this circular dual basis, which should inherit benefits of both dual basis and optimal normal basis, in finite field arithmetic implementations: multiplications, squarings, inversions and basis changes.
d. Self-dual (or self-complementary) bases A basis {e0, e1,..., em1} is called self-dual (or self-complementary) basis with respect to the trace function Tr(Ã¯Â¿Â½), if and only if Tr(eiej) = ij .
Self-duality will always mean "with respect to the trace function Tr(Ã¯Â¿Â½)," unless stated otherwise.
Property: Any polynomial basis cannot be a self-dual basis.
As observed above, a polynomial basis can be a dual basis of itself (or of a permutation of it) with respect to some linear function other than the trace function Tr(Ã¯Â¿Â½).
Theorem ([LS80]) A finite field GF(qm) has a self-dual basis over Fq if and only if either q is even, or both q and m are odd.
A basis satisfying only the condition: Tr(eiej) 0 if and only if i = j, is called a trace-orthogonal basis.
Then any finite field GF(qm) always has a trace-orthogonal basis over the field Fq. e. Self-dual normal bases A normal basis that is also self-dual is called self-dual normal basis.
A finite field GF(2m) can have more than one self-dual normal basis.
For instance, a Type II ONB is a self-dual normal basis.
Theorem (MacWilliams 
Theorem (Existence theorem): A finite field GF(qm) has a self-dual normal basis over Fq if and only if either q is even and m 0 (mod 4), or both m and q are odd.
The necessary condition is trivial for q odd, and due to Imamura 
The sufficient condition is due to Lempel 
Jungnickel, Menezes 
Later, Beth 
Geiselmann 
Deutsch, Hsu, Reed 
4.A.7.
Primitive normal bases A normal basis {, q, q ,..., q } of the finite field GF(qm) over a finite field Fq where q is any prime power, is called a primitive normal basis if is a primitive root of the multiplicative subgroup GF(qm)*.
Theorem (Lenstra 
Davenport [D69] extended to all m with q = p prime.
The author also showed that the number of choices for is at least (p 1)m. 4.A.8.
Non-conventional basis a.
All-one-polynomial (AOP) basis (Hasan 
Let = x + (f(x)) be a root of f(x).
Hence the set {, 2,..., m} is a non-conventional basis, where i= xi + (f(x)), for 1 i m. b. Equally Spaced Polynomial (ESP) basis (Itoh [I91] and Hasan 
The choice of bases The security of an elliptic curve cryptosystem does not depend on the choice of basis representation for the finite field GF(2m).
Polynomial bases and optimal normal bases are equally secure.
Moreover, all the bases are mutually transformable by using basis-change matrix multiplication, we can also use flexibly one basis for internal calculations and another basis for outputting data.
Any standard book on linear algebra always discusses the problem of using matrix multiplication for basis change or conversion.
The implementation should be rather simple.
The storage requirement is known to be about O(m2) bits over a binary finite field GF(2m).
Kaliski 
These algorithms require only O(m)-bit storage.
For software, the polynomial bases could be easier to understand and more efficient.
But the normal bases are more efficient for hardware implementation by taking advantage of the fact that squaring operation is simply a cyclic shift, while in polynomial bases, implementation of the squaring operation cannot be easier than that of multiplication.
However, this advantage must be exchanged for a larger and more complicated layouts for multiplications, unless one uses the optimal normal bases.
We also take into account that the easy squaring operations also reduce the number of multiplications in scalar point multiplication, [GG90].
4.A.10.
Comparisons of finite fields 2 m -1 ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 57 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- In implementing elliptic curve cryptosystems on finite fields, the binary finite fields GF(2m) are preferred over the prime finite fields Fp, even though Fp has performance advantages in software since it is rather more comprehensive.
The arithmetic in the binary finite field GF(2m) is easier to implement than it is in the prime finite field Fp, especially when optimal normal bases are used.
The easy squaring operations also reduce the number of multiplications in scalar point multiplication.
Point compression 
In some cryptosystems where the supersingular elliptic curves could be used, we can also reduce the number of arithmetic operations.
The ability to select the underlying finite field and its basis to optimize the finite field operations is also an advantage of an elliptic curve cryptosystem over other systems based on the discrete logarithm problem or the integer factoring problem.
4.A.11.
Composite extension finite fields and subfields When m is a composite number, m = rs, then the composite extension finite field GF(2m) can be considered an extension field of degree s over finite field GF(2r).
The finite field GF(2r) is called a subfield of GF(2m).
The elliptic curve over a subfield is also used in computing the order of an elliptic curve over a composite extension finite field using Hasse-Weil's theorem.
We can also represent elements in a composite extension finite field over its subfield using either one of the two bases discussed earlier.
We should point out that the finite field GF((2r)s) is isomorphic to the finite field m GF(2 ), but their field operations (additions and multiplications) are different depending on the irreducible field polynomials, P(x) of GF((2r)s) over GF(2r) and Q(y) of GF(2r) over GF(2).
It also depends on the posbbile factorizations of m (other than factors r and s).
The choice of those field polynomials are essential to determine the algorithmic complexity of arithmetic operation of GF((2r)s).
Using polynomial bases: Let {rs1,..., r1, r0} be a polynomial basis for GF(2m) over GF(2r).
Every element a in the finite field GF(2m) can be uniquely written in the form a = (cs1,..., c1, c0) = i =0 s -1 ci ri , or by the polynomial of the form a = cs1x s1 + ...+ c1x + c0, where each term ci GF(2r), for s 1 i 0, is also represented in a polynomial basis over F2.
Using normal bases: Let {, 2 , 2 ,..., 2 } be a normal basis for GF(2m) over GF(2r).
Then every element a in the binary finite field GF(2m) will be represented r 2r 2 ( s -1) r by a = (c0, c1,..., cs1) = c0 + c1 r 2r + c2 22r r +...+ csÃ¯Â¿Â½ 1, where ci GF(2r), for 0 i s 3r ( s -1) r 1.
In this representation, we observe that ci2 = ci, then a 2 = cs1 + c0 2 + c1 2 + c2 2 +...+ cs2 2 .
We do not have the rule "squaring is a right 1-cyclic shift" anymore.
Instead, the r 2 -th power of an element is a right cyclic shift of coefficients ci.
This implementation is most useful when, of course, r = 1 only.
______________________________________________________________________ __________________ r 2r A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 58 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Finally, the elements ci GF(2r) also can be presented by either basis over F2.
Recall that the choice of bases is not a security factor.
One can always converse simply from one basis to another.
The arithmetic operations in the composite extension finite field GF(2m) = rs GF((2 ) ) over the finite field GF(2r) do not only involve modulo 2 as in the case over F2 but also involve arithmetic operations in the finite field GF(2r) over F2.
There are many research efforts in techniques to maximize performing operations over subfields.
The following lemma focused on optimal normal bases rather than on normal bases.
Refer to Mullin [M93] or Agnew, Mullin 
Lemma: There is an optimal normal basis for finite field GF(2rs) over GF(2r) if and only if gcd(r, s) = 1 and there is an optimal normal basis for the finite field GF(2s) over F2.
In fact, let B = {, 2, 2 ,..., 2 } be an optimal normal basis for the finite field GF(2s) over F2.
Since gcd (r, s) = 1, then B is also linearly independent over GF(2r) and is an optimal normal basis of the finite field GF(2rs) over GF(2r).
The set of elements 2 ( s -1) a = d0 + d12 + d2 2 +...+ ds1 2 , where di GF(2r). has cardinality 2rs; hence it is just the finite field GF(2rs).
Refer to Green 
4.A.12.
Optimal extension fields (OEF) (Bailey 
T
he fields Finite fields of the form GF(pm), where m 
Such number p is called pseudo-Mersenne prime number.
In practice, the prime p is chosen to be a little bit smaller than the word size of the processor.
In such finite fields, we can perform efficient subfield multiplication, by reducing a 2n-bit number to roughly 1.5n bit value by "folding" the upper half into the lower half.
The small value of c helps to improve the subfield modular reduction.
There are two special types of OEF that can provide additional advantages on arithmetic operations.
Type I OEF: p = 2n Ã¯Â¿Â½ 1.
This field allows for subfield modular reduction with very low complexity.
For example, good choices for p are: 231 1 and 261 1.
Example of implementation of Type I OEF: GF((261 1)3) whose reduction binomial is x3 37.
2 ( s -1) Number theory tip Theorem: For an integer m 2, for w GF(p), the binomial xm GF(p) if and only if the following two conditions are satisfied: (i) Each prime factor of m divides the order e of element w in divide (p 1)/e; (ii) p 1 (mod 4) if m 0 (mod 4).
Corollary: If w is a primitive element for GF(p) and m is a divisor binomial xm a is irreducible over GF(p).
An important trivial result is for the case m = 2.
The binomial over GF(p) when w is a primitive element.
w is irreducible in GF(p), but does not of (p 1), then the x2 w is irreducible ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 59 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Type II OEF: has an irreducible binomial xm 2.
This field allows for a reduction in the complexity of extension field modular reduction since multiplication by w can be implemented using shiftings.
Example of Type II OEF: GF((263 259)2), GF((263 259)3) and GF((263 259)4). b.
The elliptic curves Over OEFs GF(pm), the elliptic curves have the form: y2 = x3 + ax + b, unless for the case p = 3, one uses a non-supersingular elliptic curve of the form: y2 = x3 + ax2 + b. Refer also to Baier [B01]. c. Implementation issues The inverse algorithm is the most important algorithm to discuss in implementation works.
Over OEFs, authors developed and modified some efficient advanced algorithms implemented in typical finite fields discussed earlier.
Refer to Bailey, Paar 
Kim, E. J. Lee 
They also proposed a new inversion algorithm, called MAIA (Modified Almost Inverse Algorithm), which is suited especially for OEFs.
Hoshino, K. Kobayashi, T. Kobayashi 
This method is efficient for small values of m. Implementations of elliptic curves Now, we will discuss issues on implementing elliptic curves.
Related problems are choosing an appropriate order, computing the order of a given elliptic curve, and constructing a cryptographically good elliptic curve for a cryptosystem.
4.B.1.
Conditions for selecting appropriate elliptic curves The order of the elliptic curve, N = #E(Fq), must be divisible by a prime number n that is sufficiently large, n 
This is to resist against the Pollard -algorithm.
The order n of a base point P must satisfy the MOV condition: n (qk 1) for all values k 
In practice, k = 20 is sufficient.
The best-known attacks on an elliptic curve cryptosystem satisfying these two conditions are a combination of either Pollard- or Shanks' Baby-step-Giant-step and Pollard-Hellman algorithms.
The order of the elliptic curve E must also satisfy the anomalous (or SSA) condition over prime finite fields, #E(Fp) p to resist the SSA attack.
The choice of point P of order n is not a security factor.
In fact, given an elliptic curve, there are many different points having that order which can be chosen.
Cofactor We denote by n the order of the base point P on the elliptic curve whose order is denoted by N. Usually, we should have either N = n or N = nl, where l is a small integer, called a cofactor.
In group theory, we call l the index of a subgroup generated by group element P, denoted by P, in the group E. 4.B.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 60 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Recall the inequalities of the order of an elliptic curve, we have: q + 1 2q1/2 #E(Fq) = N q + 1 + 2q1/2.
Then (q1/2 1)2/n N/n = l = (q1/2 + 1)2/n.
We can observe that l must be an integer and the difference of the upper and lower bounds of l is d = 4q1/2 /n.
Hence if n 
Therefore, the order of the elliptic curve can be computed as: #E(Fq) = N = n.l = n (q1/2 + 1)2/n, if there exists a point on E of order n 
Furthermore, the condition n 
Therefore, there is exactly one subgroup of order n in E.
This is directly from the well-known Sylow's third theorem in group theory and the subgroup is also called the Sylow n-subgroup.
4.B.2.
Methods of constructing elliptic curves There are four methods for constructing an elliptic curve in cryptography.
Generating random elliptic curves.
Using the Hasse-Weil theorem (on composite extension finite fields).
Using selected orders of elliptic curves or also referred as Complex Multiplication (CM) methods.
Using special elliptic curves such as Koblitz curves.
a.
Using a random elliptic curve We select an elliptic curve at random and compute its order by some algorithm.
For special elliptic curves, or over relatively small finite fields, there are a few effective formulas or algorithms for the order.
The best-known method for a general case is Schoof's algorithm, together with its improvements and/or extensions.
The advantages: One can change the elliptic curve as frequently as possible for security reasons.
In order to break into an elliptic curve cryptosystem, the attacker should use an algorithm to solve the ECDLP that can work on any elliptic curve rather than some particular classes of weak elliptic curves.
The disadvantages: It is tedious and still complicated to use Schoof's algorithm (and even its improved versions) to find an elliptic curve of particular order.
It is more difficult, generally, to implement a random elliptic curve efficiently, while we can optimize implementation on specific elliptic curves, such as in Koblitz curves and some cryptosystems using supersingular elliptic curves.
It is time-consuming to generate an elliptic curve and to perform operations on a general elliptic curve.
Other implementations, such as compressing and recovering a point, may need more computations than in some particular cryptosystems. b. Using Hasse-Weil's theorem This method is to construct an elliptic curve over a finite field GF(2m) where m is a composite number.
We first construct an elliptic curve over a finite field GF(2n) for some small factor n of m such that we can compute its order easily.
Then we lift it to an elliptic curve over a finite field GF(2m) where its order can be computed rather easily using the Hasse-Weil's theorem.
We should compute rather easily that #E(GF(2n)) = 2n + 1 t, then we will have #E(GF(2m)) = 2m + 1 m/n m/n, where and are complex numbers satisfying the ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 61 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- equation qT2 tT + 1 = (1 T)(1 T).
More practically, + = t and = q = 2n.
Then the power sum Lk = k + k is the k-th term in the sequence of symmetric functions: L1 = t, L2 = t2 2q, and for all k 3, Lk = tLk 1 q tLk 2.
The sequence Lk is usually called Lucas sequence.
The order #E(GF(2m)) then has a small factor, namely #E(GF(2n)).
This method of choosing an elliptic curve works on composite extension finite fields and can create only a limited number of elliptic curve orders.
This construction method can increase the performance in generating elliptic curves and doing elliptic curve operations.
But in the security aspect, these elliptic curves (also referred as subfield elliptic curves) are considered weak curves.
c. Complex Multiplication (CM) methods A Complex Multiplication method allows choosing an appropriate elliptic curve order, before constructing explicitly an elliptic curve of that order.
In practice, this method is fast, and the big advantage is to eliminate the need for a point counting algorithm.
Two methods mentioned in literature are due to Atkin 
Atkin-Morain method [Mo91] The method works on a prime finite field Fp. Recall that #E(Fp) = p + 1 t, where 2 t 4p.
It is based on a theorem of the primality-testing algorithm using elliptic curves.
Theorem: Let p be a prime that can be written as 4p = t2 + Ds2 for a given D.
Then there exists an elliptic curve E defined over Fp such that 4.#E(Fp) = (t 2)2 + Ds2.
We call D a Complex Multiplication discriminant for p, or the elliptic curve E has CM property by D, or in fact, by (D)1/2.
If we know D for a given curve E, we then can solve for t (and s) in the equation: 4p = t2 + Ds2, and know the order #E(Fp).
Atkin-Morain algorithm: Compute t = p + 1 #E(Fp) = p + 1 N. Find an integer s and a square-free positive integer D such that Ds2 = t2 4p.
This step can be done since if N is an order of an elliptic curve #E(Fp), we must have t2 4p.
Hence A = 4p t2 0, and it can be written uniquely as A = Ds2, where D is a square-free positive integer.
Then we write: 4p = t2 + Ds2.
Construct the Hilbert polynomial HD(X) of j(D1/2), using the above formula.
Find a root r of the equation HD(X) 0 (mod p).
Create a non-supersingular elliptic curve whose j-invariant is r.
This algorithm can be generalized over finite field Fq, where q = pm.
Although it is possible to choose the order of an elliptic curve before choosing the underlying finite field, in usual cryptographic practice, one prefers to choose the finite field in advance so one can exploit some efficient implementations.
This method usually generates small d.
The subset of elliptic curves generated by this method is considerably smaller than the number of elliptic curves available.
Those elliptic curves are thought to be insecure, but no weakness is known so far.
Refer to Miyaji ([Mi91], [Mi93]
Lay-Zimmer method [LZ94] This method works on finite fields of characteristic 2 and also over prime finite fields.
It solves the following problems: ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 62 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Given an integer N 
The algorithm is based on constructing an elliptic curve E(GF(2m)) that has a given j-invariant.
However, the rest of the algorithm is based heavily on the algebraic number theory whose context is too complicated to be described in this document.
Refer to MÃ¯Â¿Â½ller 
For CM methods and other works on Koblitz cureves, readers may refer to Koblitz ([K90],[K92]
There is current research mentioning general doubts about constructing elliptic curves extra internal structure, such as with special coefficients (i.e., Koblitz curves), with special Complex Multiplication property and/or over composite extension finite fields.
There is a tradeoff between performance and security in implementing elliptic curve cryptosystems using such special curves and/or finite fields.
4.B.3.
Finding a point of given prime order on an elliptic curve The order n of a point P O on an elliptic curve is a positive integer such that nP = O and mP O for any integer m such that 1 m 
The order n of a point must divide the order N of the elliptic curve.
In fact, it is true for any group.
If the elliptic curve order N = #E is a prime number, then the group is cyclic, and obviously all points except the point at infinity O are of order N. Choosing a point P of prime order n: A simple method is usually applied in cryptographic practices when n is a large prime.
Then the factor l = #E/n will not be divisible by n. Choose a random point Q O on the elliptic curve E, then verify whether the point P = lÃ¯Â¿Â½Q has order n.
This can be done simply by checking that nÃ¯Â¿Â½P = O.
(Since n is prime, there is no other positive integer m 
If it is true, then P = lÃ¯Â¿Â½Q is the point we need; otherwise, choose another point Q and repeat.
4.B.4.
Methods/formulae to compute the order of an elliptic curve It should be noted that it is easy to check whether the number of points on an elliptic curve is correct when it is known, while an efficient algorithm to find out that number is still a difficult task.
In chapter 1, we already presented formulae and algorithms for counting the order of an elliptic curve group, such as Hasse-Weil theorem, direct formulae using Legendre symbol and trace function, Shanks' Baby-step-Giant-step algorithm and Schoof's algorithm. a.
The order of an elliptic curve of the following special forms Ep(a, 0): y2 = x3 + ax, for a 0 (mod p) and p 1 (mod 4) ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 63 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- or Ep(0, b): y2 = x3 + b, for b 0 (mod p) and p 1 (mod 3), over a prime finite field Fp are discussed thoroughly in Bressoud [B87] and Ireland 
Case 1.
For prime p 1 (mod 4) and Ep(a,0): y2 = x3 + ax, for a 0 (mod p).
Let r = s + it be a complex prime (where s and t are integers,) and let r = s it be the complex conjugate of r, which satisfy the conditions r 1 (mod 2 + 2i) and p = r r = s2 + t2.
Let (r) = (s + it) = s be the real part of number r.
Then #Ep(a, 0) = p + 1 2[R4(a) r ], where the symbol R4 is defined by R4(x) = x(p 1)/4 (mod r).
The orders in this case are always even.
Explicitly, the elliptic curve orders will fall into one of only four cases listed in this table.
The order #Ep(a, 0) is If R4( a) = (a)(p 1)/4 (mod r) 1 p + 1 2( r ) = p + 1 2s 1 p + 1 2( r ) = p + 1 + 2s i p + 1 2(i r ) = p + 1 2t i p + 1 2(i r ) = p + 1 + 2t Table 4.4.
Orders of elliptic curves Ep(a,0): y2 = x3 + ax, a 0 (mod p), over a prime finite field Fp, p 1 (mod 4) Observe that r 1 (mod 2 + 2i) or (2 + 2i) | (r 1) = [(s 1) + it].
Hence we derive a relation on their squares of absolute values.
It is: 8 | [(s 1)2 + t2] = p + 1 2s.
So we can solve the system of equations s (p + 1)/2 (mod 4) and p = s2 + t2 for values s and t, such that 1 s, t 
Then choose and check an appropriate value of r = Ã¯Â¿Â½ s Ã¯Â¿Â½ it 1 mod (2 + 2i).
Case 2.
For prime p 1 (mod 3) and Ep(0, b): y2 = x3 + b for b 0 (mod p).
Let w be a non-trivial cubic root of 1, (i.e., w2 + w + 1 = 0,) and w = e2i/3 = (1 + 1/2 i3 )/2.
Let r = s + wt be a complex prime, where s and t are integers, satisfying the conditions r 2 (mod 3) and p = r r = s2 st + t2.
In this case, we note that w2 = (1 i31/2)/2 = w and r = (s t) wt, for simpler calculations.
Then #Ep(0, b) = p + 1 + 2[R6(4b) r ], where the symbol R6 is defined by R6(x) = x(p 1)/6 (mod r).
Explicitly, the elliptic curve orders will fall into one of only six cases described in table 4.5.
If R6(b) Equivalently, if R6(4b) = The order #Ep(0,b) is = b(p 1)/6 (mod r) (4b)(p 1)/6 (mod r) (p1)/3 u=4 (mod r) 1 p + 1 + 2( r ) = p + 1 + 2s t u 1 p + 1 + 2( r ) = p + 1 2s + t w.u w p + 1 + 2(w r ) = p + 1 s + 2t w.u w p + 1 + 2(w r ) = p + 1 + s 2t 2 2 w .u w p + 1 + 2(w2 r ) = p + 1 s t 2 2 w u w p + 1 + 2(w2 r ) = p + 1 + s + t Table 4.5.
Orders of elliptic curves Ep(0, b): y2 = x3 + b, b 0 (mod p) over a finite field Fp, p 1 (mod 3) 4.B.5.
Schoof's and Satoh's algorithm for point-counting Refer to chapter 1 for a short summary of development of the algorithms by many researchers such as Schoof, Atkin, Elkies, Couveignes and Lercier.
We choose not to go ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 64 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- deeply into the theory behind these developments of the algorithms at the present time, because of the heavy burden of introducing a lot of difficult materials of the mathematics underlying.
We have discussed how to represent elements of finite fields and how to build an elliptic curve over the underlying finite fields for an elliptic curve cryptosystem.
In the next section of this chapter, more features or issues on the implementations of operations of such cryptosystems will be discussed.
They are scalar point multiplication formulae and algorithms, representations of points on an elliptic curve and special algorithms on Koblitz curves and composite extension finite fields and other topics.
Implementations of elliptic curve arithmetic operations Many topics in implementations of arithmetic operations over elliptic curves will be discussed in this section: scalar point multiplications, methods representing points of an elliptic curve and Complex Multiplication methods...
The most basic operation is adding two points or doubling a point on an elliptic curve.
It is more expensive computationally than a basic operation in a symmetric key cryptosystem (a block encryption/decryption).
But it is still much faster than a basic modular multiplication over a cyclic group whose order is of the same security level.
We now discuss efficient algorithms to expedite implementation procedures in elliptic curve cryptosystems.
4.C.1.
Scalar point multiplication: basic methods One crucial operation is scalar point multiplication since it determines the speed of an elliptic curve cryptosystem.
We will multiply a point P on an elliptic curve E by a positive integer k. By definition, kP = 1+ 4+ L 4P .
This problem is analogous to P 4 24+3 P 4.C. raising an element to the k-th power in the multiplicative subgroup GF(q)*. a.
Double-and-add method This most basic method uses the binary expansion of the number k. Let write k = (kr1,..., k0) in base 2, where kr 1 = 1 and r = log2 k + 1.
Let Pr 2 = P.
Then compute Pi 1 = 2Pi + kiP, for all i, r 2 i 0.
Then kP = P1 = 2P0 + k0P.
This method requires (r 1) doublings and probabilistically about (r 1)/2 additions or at most (r 1).
Observe that we can reduce the number of arithmetic operations when the number of bits 0 is increased.
This is the basic idea for methods, which try to improve the implementation of scalar point multiplication.
b. Addition-subtraction method For elliptic curve implementation, the methods, which included subtractions, are more attractive than the corresponding methods, which included divisions in calculating power in finite fields.
The reason is division or inversion in finite fields is a more costly operation than multiplication, while subtraction is just as costly as addition in elliptic curve operations.
The basic method uses the binary expansion of k and 3k.
Let l = 3k = (lr1,..., l0) and k = (kr1,..., k0) such that the leftmost bit lr1 must be 1.
That is, a few leftmost bits of k are added bits 0 from the canonical binary form of k. Let Pr 1 = P.
Then compute Pi 1 = 2Pi + (li 1 ki 1)P, for all i such that r 1 i 2.
Then kP = P1 = 2P2 + (l1 k1)P. ______________________________________________________________________ __________________ k terms A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 65 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- This method requires (r 2) doublings and probabilistically about (r 2)/2 additions/subtractions or at most (r 2).
This method in fact is an easily described version of the following method.
c. Addition-subtraction method using NAF We now use the canonical encoding called the non-adjacent form (NAF) of scalar k.
This coding employs a signed binary expansion (using 0 and Ã¯Â¿Â½1) that has the property that no two consecutive coefficients are nonzero.
The NAF of an integer is unique and has the fewest nonzero coefficients of any signed binary expansions.
There are many ways to construct the NAF.
One way is just described previously, using bits in k and 3k.
The NAF can be computed similarly by the same method for the binary form.
That is, repeating dividing by 2 to collect the remainders, except an important rule: for the nonzero remainder, the corresponding quotient must be even.
This exception helps to make the next remainder be zero.
Let k be in NAF, k = (kr1,..., k0).
Let Pr1 = P.
Then compute P i1 = 2Pi + ki1P, for all i, r 1 i 1.
Then kP = P0 = 2P1 + k0P.
This method requires (r 1) doublings and probabilistically about (r 1)/3 additions or at most (r 1)/2.
Eventually, we can combine this method with the sliding window method for a more efficient implementation - the signed binary window method that will be discussed later.
d. m-ary method (or 2d-ary method) This method is generalized from the double-and-add method, where the m-ary expansion is used instead of binary form, where m is a power of 2.
Let m = 2d, where d 
We start with the binary expansion of the number k = (ks1,..., k0), where we may pad an extra number of bit 0's to the left side of the bit string to make s = d.r for some integer r.
Then we have the m-ary expansion of k of the form k = (Kr1,..., K0) where each Ki is a d-bit string and Kr1 (0...0).
First we pre-compute all points 2P, 3P,..., (2d 1)P.
They will cover all possible points of the form KiP.
We look up for the point Pr2 = Kr1P, and compute Pi1 = 2dPi + KiP, for all i such that r 2 i 0.
Then kP = P1 = 2dP0 + K0P.
This method requires (2d 2) pre-computations (and memory storage), (r 1)d = s d doublings and probabilistically about (r 1)(1 2d) additions.
We can observe that the larger d is, the more pre-computations are needed.
With a little calculus, we can find the optimal d to minimize the total of additions: A(s, d) = 2d 2 + s d + [(s/d) 1] (1 2d) .
Bit recoding techniques, such as signed binary expansions, are also used to improve the binary or m-ary methods.
Refer to KoÃ¯Â¿Â½ [Kc91] and Eeciolu 
e.
The 2d-ary NAF form It is possible that one can combine the addition-subtraction method with the 2dary method.
Particularly, the addition-subtraction method using the 2d-ary NAF form that is a binary form with the property that there is at most one non-zero term in d consecutive coefficients.
This form always uniquely exists and is easy to compute.
The computing method is similar to that for the NAF form, except that the corresponding quotient to the ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 66 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- non-zero remainder must be divisible by 2d1.
The pre-computation must store all points: Ã¯Â¿Â½P, Ã¯Â¿Â½3P,..., Ã¯Â¿Â½(2d 1 1)P.
The addition-subtraction method is a special case for d = 2.
4.C.2.
Scalar point multiplication: advanced methods a.
Sliding window method ([Kc95]) This method aims to separate zero words so we can skip an addition in the m-ary method discussed above.
Instead of decomposing k = (ks1,..., k0) into words of d-bit length, we now decompose k into zero and nonzero words, or windows Wi of varying lengths li.
Let d be the maximum length of all nonzero windows.
Then we need to precompute only "odd scalar multiplying" points 3P, 5P,..., (2d 1)P We write k = (Wr 1,..., W0) where Wr 1 is a non-zero window (or window number). l Look up for Pr 2 = Wr 1P.
Then compute Pi1 = 2 i Pi + WiP, for all i such that r 2 i 0.
Then kP = PÃ¯Â¿Â½ 1 = 2l0 P0 + W0P.
There are two strategies to partition a binary expansion into windows: constant length and variable length nonzero windows.
Constant length nonzero windows This strategy tries to produce zero windows of arbitrary length and nonzero windows of a fixed length d.
A nonzero window will start when a bit 1 is encountered as we scan the bits from rightmost bit to leftmost.
This method requires (2d 2)/2 = 2d1 1 pre-computations (and memory storage), (s d) doublings and probabilistically about A additions, where A is the number of non-zero windows, A s/d.
Refer to KoÃ¯Â¿Â½ [Kc95] for more analytic results on the value of A.
In summary, this method reduces the number of additions by 3 to 7%, for 128 s 2048, less than the m-ary method.
Variable length nonzero windows This strategy tries to produce nonzero windows whose right-end and left-end bits are both 1.
Two parameters are to be decided: the maximum length d of nonzero windows and the maximum number r of adjacent 0's allowed inside any nonzero window.
This method generally tries to decrease further the average number of nonzero windows when d and r are chosen optimally.
We should choose 4 d 8.
This method requires (2d 2)/2 = 2d1 1 pre-computations (and memory storage), probabilistically about A additions, where A is the number of non-zero windows, A s/d and D doublings.
Refer to KoÃ¯Â¿Â½ [Kc95] for more analytic results on the values of A and D.
In summary, this method reduces the number of additions by 58%, for 128 s 2048, less than the m-ary method.
b. Signed binary window methods These methods transform an ordinary binary expansion B into a signed binary expansion S.
(The transformations are also called "bit recoding" techniques.)
Again, the methods or algorithms using "signed" expansion are much more efficient in implementing elliptic curve operations than in finite field operations since the subtraction is just as costly as addition.
The purpose is to skip a bit string of 1's (in addition to bit strings of 0's, as usual) to reduce the number of additions.
Morain-Olivos' algorithm ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 67 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- This algorithm reduces the weight of the signed binary form S, i.e., the number of non-zero digits, denoted by #1(S).
The idea is that a block of n bits 1 can be replaced by a bit string that is a block consisting of a bit 1 followed by n bits 0 and then minus 1.
That is: 11L1 = 100L 0 - 1 .
This observation is extracted from the equality: 13 1 3 2 2 2n+1 1 = (2n + 2n 1 + ...+21 + 20).
As a result, (n 1) doublings and (n 1) additions (i.e., 2(n 1) total additions) can be replaced by n doublings and 1 subtraction (i.e., (n +1) total additions).
In other words, this method tries to construct two positive integers k+ and kÃ¯Â¿Â½ such that k+ k = k.
The total computation for (k+ k).P is less than that for kP. Note that there are not two separate computations of k+P and kP, but actually the computations merge together: kP only shows up in a few subtractions corresponding to the positions of its bits 1 in the scalar k.
The same idea is to deal with a special string that has isolated 0's.
We observe that: k = 1L1 0 1L1 = 1 0L 0 1 0LL 01 = 1 0L 0 - 00L 0 10LL 01 , where bit 1 denotes {{ {14 { {14 423 423 n bits m bits n bits ( m-1) bits n + m +1 bits n bits ( m-1) bits n bits n bits (1), and we assume m 2.
This observation is extracted from the same equality above, applied twice.
Then we have the formula: kP = 2m.(2n+1.P P) P. That is, an isolated 0 inside a block of bit 1's will contribute only two subtractions/additions and one extra doubling, instead of (n + m 1) additions.
Morain-Olivos [MO90] provides detailed estimations of implementation cost.
In summary, the method reduces about 3% for 100-digit number and 2.7% for 300-digit number.
Jedwab 
The original idea was proposed by Mitchell 
MÃ¯Â¿Â½ller [Mu98] discussed improved versions over Morain-Olivos' method.
A generalization of the Morain-Olivos' algorithm We can generalize this result for k being a string of (b 1) isolated bits 0 sandwiched among b blocks of bits 1, where b is larger than 2, the following can be written: k = 1LL10L1LL10 1LL1 = 1 0LL2LL 0 - 00L 0 1L 0LL 0 10LL 0 1, 13 13 13 2 2 2 14 L44 4 3 { 14 14 423 423 N1 bits N b -1 bits Nb bits N1 +L+ Nb + ( b -1) bits N1 bits N b -1 bits ( Nb -1) bits assuming Nb 2.
This observation is also derived from the above equality: 2n+1 1 = (2n + 2n1 + ...+ 21 + 20).
Then we can obtain the following formula: kP = 2 N b Ã¯Â¿Â½(2 N b-1 +1Ã¯Â¿Â½[L(2 N1 +1Ã¯Â¿Â½P - P)L] - P) - P.
This formula dramatically generalized the application of Morain-Olivos' algorithm such that b can be any positive number greater than 2, rather than being restricted to b = 2 only.
By applying this algorithm, (N1 + ...
+ Nb 1) additions were replaced by only b subtractions/additions and one extra doubling.
The savings in the number of arithmetic operations are significant when the sum (N1 + ...
+ Nb) is much larger than b, which should be obtainable for those cases of k. Koyama-Tsuruoka's algorithm ([KT92]) This algorithm improved the above methods by increasing the average length of zeros in the signed binary expansion using { 1 , 0, 1}, where bit 1 denotes (1).
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 68 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- A binary string of a non-zero window B = (1, bn,..., bi,..., b1, 1) in k will be transformed to a signed binary string of the form T = (1, 0, tn,..., ti,..., t1, 1 ), where ti = bi 1, for all 1 i n.
This transformation is effective (i.e. actually decreases the weight of the bit string) only when the difference between the numbers of bits 1 and bits 0 is: Diff(B) = #1(B) #0(B) 
However, we should keep in mind that the transformation also costs us one extra doubling because of the extra bit.
Both methods (by Koyama-Tsuruoka and Morain-Olivos) generate a signed bit string with the same weight, but the average length of zero runs by the Koyama-Tsuruoka method is greater than that of the Morain-Olivos method.
By this method, one needs to pre-compute only the odd scalar points Ã¯Â¿Â½3P, Ã¯Â¿Â½5P,..., upto Ã¯Â¿Â½(2d 3)P, since this algorithm never allows the points Ã¯Â¿Â½(2d 1)P to appear.
In fact, this transformation is extracted from the equality: 2n+2 2n+1 = 2n+1 = (2n + 2n 1 + ...+21 + 1 + 1).
Using the relationship 1 = bi ti, for all 1 i n, we then have: 2n+2 + (tn2n + tn12n1 + ... + t121 + 1) = 2n+1 + (bn2n + bn12n1 + ... + b121 + 1).
Refer to Koyama 
Note that, the similar idea in the Koyama-Tsuruoka's algorithm was also discussed in KoÃ¯Â¿Â½ [Kc91].
A generalization of Koyama-Tsuruoka's algorithm Instead of applying this algorithm for a non-zero window only, we try to apply for an arbitrary bit string k = (bn,..., b1, b0), where without loss of generality, we may assume bn = 1.
For all 0 i n, let ti = bi 1, then again insert it into the arithmetic identity: 2n+1 = (2n + 2n1 + ... + 21 + 20) + 1, we can obtain the following identity: 2n+1 + (tn2n + tn12n1 + ... + t121) + t020 1) = (bn2n + bn12n1 + ... + b121 + b020).
When b0 = 1, then t0 = 0, this approach will transform k to the string of digits T = (1, tn,..., t1, 1 ), where the last digit 1 = 1.
This is Koyama-Tsuruoka's algorithm for non-zero window B = (bn,..., b1,1).
When b0 = 0, then t0 = 1, this approach will transform k = (bn,..., b1,0), to the string of digits T = (1, tn,..., t1, 2 ), where the last digit 2 = 2.
This last digit does not affect the scalar point multiplication (kÃ¯Â¿Â½P) at all.
In the very last step of a given scalar point multiplication algorithm, we then subtract a double of a point, 2P, instead of the point P itself.
The point 2P is available for free since it is always computed during the process.
If we use other m-ary methods or window methods, the digit 2 obviously is not a concern anyway.
We need only minor changes in pre-computations.
The number of non-zero digits in T is #non-0(T) = 2 + i =1 n ti = 2 + i =1 n bi - 1 = 2 + 1 i n , bi = 0 (1) = 2 + #0(k'), where k' = (bn,..., b1).
Hence this transformation is effective if the condition 2 + #0(k') 
Since #0(k') = #0(k) 1, we can rewrite the condition as: Diff(k) = #1(k) #0(k) 
Hence Koyama-Tsuruoka's algorithm can extend for any bit strings, which satisfy this condition.
Again, the transformation also costs us one extra doubling because of the extra bit.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 69 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Other algorithms/discussions Jedwab 
The original idea was proposed by Mitchell 
MÃ¯Â¿Â½ller [Mu98] discussed improved versions over Morain-Olivos' method.
All algorithms described above are based on sliding window and bit manipulations.
They gave almost the same level of performance.
They are all doing better than a typical m-ary method.
However, no method actually dominates over the other methods yet.
There is no significant difference or breakthrough in the algorithms showed above.
The attractive point again is using "negative" digits (e.g., 1 = 1 and/or 2 = 2) to have the subtractions involved since the cost of subtraction is the same as that of addition in elliptic curve implementation.
Refer to Gollmann, Han 
d. Methods using addition chains/sequences The problem of optimal addition chains is to find the fewest additions needed to compute a positive integer k starting from 1.
It is used to compute kP from P with the fewest elliptic curve additions (originally, to compute the power xk from x with fewest multiplications).
An addition chain [Ai] of k of length L is of the form: 1 = A0 
Note that in an addition chain, k occurs at the very end of the chain, while in an addition sequence, k just needs to occur someplace in the sequence.
For our practical purpose, now we mention only addition chains.
Obviously, there can be many different addition chains for a given positive integer k. Naturally, we are most interested in finding the addition chain of minimum length since it will help to minimize the number of arithmetic operations.
In another version, we call an addition/subtraction chain, when [Ai] satisfies weaker conditions: for 1 i L, Ai = Aj + Am or Ai = Aj Am, where i 
A star chain is an addition chain [Ai] satisfying: for 1 i L, Ai = 2.Ai 1 (a doubling) or Ai = Ai1 + Al, ("star step") where i 1 
That is, one summand must be the very previous element.
A star step is called a "simple step" when l = 1.
Refer to Downey, Leong 
Generally, computing the addition chain of minimum length is a very difficult problem, but there are simple algorithms to produce good addition chains, even near minimum length.
The most common algorithm is using the binary form as in double-andadd (or addition-subtraction) method, even though it usually produces addition chain ______________________________________________________________________ __________________ c.
A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 70 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- larger than minimum length.
Finding the addition chain with the minimum length will benefit the algorithms to compute the scalar point multiplication kP, since it will minimize the number of required additions.
Bos 
This method will be significant when sliding window methods of large width are used.
In those cases, the pre-computed table will require a large number of computations and also storage.
We do not even need the addition chain for k. Instead, we need to create only an addition sequence that consists of the needed window numbers only.
These window numbers are of course less than 2w, where w is the window width.
Hence they are much smaller than k itself.
Then using one of the methods discussed previously, we can create the addition chain for k. Yacobi [Y91] proposed a similar method, systematically developing into a heuristic algorithm (that is claimed to be a modification of the Lempel-Ziv data compression algorithm.)
We will apply a 2d-ary method (or sliding window method) where we will pre-compute only those intermediate scalar point multiplications that will be needed.
However, this algorithm is not better than a 2d-ary method for small scalar k, less than 512 bits, but it is more efficient for larger k. Most recently, Aigner 
4.C.3.
Scalar point multiplication: other methods a.
Using projective coordinates Menezes 
It is to remove the inversion operations in point addition or doubling operations in the intermediate steps in any scalar point multiplication algorithm implemented.
At the final step, we can use a single inversion to convert it to affine coordinates as usual.
Menezes 
Koyama 
- - Let P = (x1, y1, 1) and Q = (x2, y2, z2).
We can rewrite Q = ( x2 z2 1 , y2 z2 1 ,1) and apply the regular point addition formulae (for affine coordinates) to find R = P + Q = (x'3, y'3, 1).
Then let z3 be the common denominators of x'3 and y'3, we can write R = (x3, y3, z3).
The completed results for all three usual cases of elliptic curves over finite fields are summarized in the table 4.6.
For convenient reference, we also include the formulae of the additive inverse of a point in the first column.
Equation of elliptic R = (x3, y3, z3) = (x1, y1,1) + (x2, y2, z2) = P + Q curve E over Fq in ---------------------------------------------------------------------- --Let A = x1z2 + x2, B = y1z2 + y2, X = x2 x1z2, Y = y2 y1z2 affine coordinates Over Fp, p 2, 3 if P Ã¯Â¿Â½Q XT 2 3 x3 = y = x + ax + b 2 2 if P = Q, 2 y1 ( S - 8 x1 y1 ) = 16(4a3 + 27b2) ( x y - x y ) X 2 z - YT if P Ã¯Â¿Â½Q 0 y3 = 1 2 22 1 2 2 4 P = (x1, y1, 1) S (12 x1 y1 - S ) - 8 y1 if P = Q , Q = ( x2 , y2 , z2 ) Then ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 71 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Q = (x2, y2, z2) X 3z z3 = 3 8 y1 2 if P Ã¯Â¿Â½Q if P = Q , 2 where T = Y z2 AX 2 and S = 3 x12 + a.
(A slightly revised version of Koyama 
Point addition formulae in the projective coordinates (xz, yz, z) With the above formulae, we can compute the scalar point multiplication, kP = k.(x1, y1, 1) = (x, y, z), by repeated additions, as usual.
Then by a single inversion at the very end step to get z1, we can write kP = (xz1, yzÃ¯Â¿Â½ 1).
The disadvantage of this method is that it requires larger memory to store points of three coordinates on an elliptic curve.
We can develop other scalar point multiplication formulae by using the Jacobian projective coordinates, (z2x, z3y, z) , z 0.
Again, let P = (x1, y1, 1) and Q = (x2, y2, z2).
- - We rewrite Q = ( x2 z 2 2 , y 2 z 2 3 ,1) and apply the regular addition formulae (for affine coordinates) to find R = P + Q = (x'3, y'3, 1).
Then we convert it back to the original Jacobian projective coordinates.
The completed results for all three usual cases of elliptic curves over finite fields are summarized in the table 4.7.
Equation of elliptic R = (x3, y3, z3) = (x1, y1,1) + (x2, y2, z2) = P + Q curve E over Fq in ---------------------------------------------------------------------- -2 3 2 3 affine coordinates Let X = x1 z2 + x2 , Y = y1 z2 + y2 , C = x2 - x1 z2 , D = y2 - y1 z2 Over Fp, p 2, 3 D 2 - XC 2 if P Ã¯Â¿Â½Q 2 3 x3 = 2 y = x + ax + b 2 if P = Q , S - 8 x1 y1 = 16(4a3 + 27b2) 0 P = (x1, y1, 1) Q = ( x2 , y2 , z2 ) ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 72 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Then Q = (x2, y2, z2) 2 3 D ( x1 z3 - x3 ) - y1 z3 y3 = 3 S ( 4 x1 y12 - x3 ) - y1 z3 if P Ã¯Â¿Â½Q Cz2 z3 = if P = Q, 2 y1 if P Ã¯Â¿Â½Q if P = Q , where S = 3x12 + a.
(A slightly revised version of Cohen, Miyaji 
Point addition formulae in the Jacobian projective coordinates (z2x, z3y, z) Refer to Agnew, Mullin 
b. Montgomery's method This method is extracted from a work of Montgomery [M87].
In the table 4.8., we show the relations of the x-coordinates of 2 points (P + Q) and (P Q).
Equation of elliptic curve E over finite field P + Q = (x3, y3) 
Addition formulae using the Montgomery's method Hence, for both supersingular and non-supersingular elliptic curves over binary finite field GF(2m), we can compute the x-coordinate x3 of (P + Q) with only one ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 73 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- inversion and a few finite field additions from the x-coordinates of P, Q and (P Q).
The y-coordinates are not involved in the computations.
However, if over prime finite field Fp, the computation must involve also the ycoordinates y1 and y2.
Hence the Montgomery's method performs better over binary finite fields than over prime finite fields.
To compute point kP, where k = (kr1,..., k0) in base 2, we first compute the point 2P.
Thereafter, given a pair of points (mP, (m + 1)Ã¯Â¿Â½P), we then compute in step i either (2mÃ¯Â¿Â½P, (2m + 1)Ã¯Â¿Â½P) if ki = 0, or ((2m + 1)Ã¯Â¿Â½P, (2m + 2)Ã¯Â¿Â½P) if ki = 1.
The Montgomery's method has a considerably slower speed since in each step (for each bit) we must compute A doubling in order to get the point 2mÃ¯Â¿Â½P or (2m + 2)Ã¯Â¿Â½P = 2(m + 1)Ã¯Â¿Â½P) and A point addition with point (Ã¯Â¿Â½P) to get (2m + 1)Ã¯Â¿Â½P.
On the other hand, these computations also provide one advantage of this method: the ability of resistance against the power differential analyses attacks since there is no distinction on operating over bit 0 or bit 1.
One may even use projective coordinates in the Montgomery's method to reduce the inversion (or division).
We summarize the formulae in the table 4.9.
Equation of elliptic curve E over finite P + Q = (x3, y3, z3) 
Addition formulae using the Montgomery's method in the projective coordinates (xz, yz, z) Hence, over binary finite fields GF(2m), for both supersingular and nonsupersingular elliptic curves, we can compute the x-coordinate x3 of (P + Q) with a few field operations from z2 and x-coordinates of three points P, Q and (P Q).
Over prime finite fields Fp, the computation must involve also the y-coordinates y1 and y2.
Moreover, no inversion or division is required.
We can do similar computations over the Jacobian projective coordinates of the form (z2x, z3y, z) , z 0.
Equation of elliptic curve E over P + Q = (x3, y3, z3) and P Q = (x4, y4, z4), where finite field Fq P = (x1, y1,1), Q = (x2, y2, z2) and P Ã¯Â¿Â½ Q 3 Over Fp, p 2, 3 x3 = x4 4y1y2 z 2 2 3 y = x + ax + b z3 = z4 (and = 16(4a3 + 27b2) 0) ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 74 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------4 Non-supersingular elliptic curve over x3 = x4 + z 2 x 1 x2 m GF(2 ) z3 = z4 y2 + xy = x3 + ax2 + b (and b 0) 6 Supersingular elliptic curve over x3 = x4 + z 2 c 2 m GF(2 ) z3 = z4 y2 + cy = x3 + ax + b (and c 0) Table 4.10.
Addition formulae using the Montgomery's method in the Jacobian projective coordinates (z2x, z3y, z) Again, over binary finite fields GF(2m), for both supersingular and nonsupersingular elliptic curves, we can compute the x-coordinate x3 of (P + Q) with a few field operations from z2 and x-coordinates of three points P, Q and (P Q).
Over prime finite fields Fp, the computation must involve also y-coordinates y1 and y2.
Moreover, no inversion or division is required.
In summary, the Montgomery's method always works better over binary finite fields than over prime finite fields for either affine coordinates or projective coordinates.
c. Demytko's work ([D94]) Let P = (x, y) be a point on an elliptic curve E: y2 = x3 + ax + b over finite field Fp with its discriminant = 16(4a3 + 27b2) 0.
Let Pk = k.P = (xk, yk).
2 ( xk - a) 2 - 8bxk ( xk2 - a) 2 - 8bxk If yk 0 (mod p), then x2k = .
= 2 3 4 yk 4( xk + axk + b) (a - xk xk +1 ) 2 - 4b( xk + xk +1 ) If xk xk+1 and x 0 (mod p), then x2k+1 = . x( xk - xk +1 ) 2 4b + 2(a - xk xk +1 )( xk + xk +1 ) If xk xk+1 and x 0 (mod p), then x2k+1 = + x. ( xk - xk +1 ) 2 We can observe that xk xk+1 (mod p) only when Pk = Pk+1 or (2k + 1)Ã¯Â¿Â½P = O. Recall from the Montgomery's method, we have a more general formula 4b + 2(a - xi x j )( xi + x j ) If xi xj then xi+j = + xij. ( xi - x j ) 2 This yields a chosen message attack proposed by Kaliski [K97].
We can also use the projective coordinates in the above formulae.
For example, we denote P = (X, Y, Z) and Pk = k.P = (Xk, Yk, Zk).
Then we have: X2k = ( X k2 - aZ k2 ) 2 - 8bX k Z k3 ; Z2k = 4Zk ( X k3 + aX k Z k2 + bZ k3 ) and X2k+1 = Z.[(XkXk+1 aZkZk+1)2 4bZkZk+1(XkZk+1 + Xk+1Zk)]; Z2k+1 = X(XkZk+1 Xk+1Zk)2.
d. Direct multiplication formulae and others For practical implementation, the inversion of finite field elements is the most expensive operation to perform in finite fields.
Guajardo 
Instead of repeating doubling P many times to compute the intermediate points 2P, 22P,...,2d1P, which may be of no use at all, we should derive a general direct formulae to compute point (2d.P) for any positive integer d, as large as one can.
In each formula, we try to reduce the number of inversions to a possible minimum.
Those formulae can be applied in the pre-computations of 2d-ary methods or window methods to improve the efficiency.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 75 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Shamir's speed-up algorithm to compute point (aP + bQ) is to go through the non-adjacent signed binary expansions of the scalars a and b at the same time, doubling and adding/subtracting P, Q, and P Ã¯Â¿Â½ Q.
This algorithm is claimed to have fast speed but it also requires more memory.
Others, such as Lee 
Gallant, Lambert 
4.C.4.
Algorithms on composite extension finite fields For a composite extension finite field, we mean a finite field of the form GF(2r), where r is a composite number r = nm.
Then the finite field GF(2mn) is considered an etension field of order m of the subfield GF(2n), (or an extension field of order n of the subfield GF(2m)).
Refer to Green 
Multiplicative inversion over composite extension finite fields Guajardo [G97], Paar [P95]
It takes advantage of calculations in the subfield GF(2n) of small degree n.
The reduction polynomial of GF(2nm) over GF(2n) is P(x).
The inverse of a non-zero element A GF(2nm) is defined by: A1 = (Ar)1Ar1, where r = (2nm 1)/(2n 1) and Ar GF(2n).
First, the term Ar1 will be computed using addition chains since r 1 = 2n + 22n + ... + 2(m1)n. Second, we observe that the product Ar of two elements A and Ar1 in GF(2nm) is, in fact, in the subfield GF(2n).
This helps to reduce the cost in comparison with general multiplication in the composite extension finite field GF(2mn) if we choose the reduction polynomial P(x) carefully.
Third, the inversion (Ar)1 is easily performed in the subfield GF(2n).
The final product between an element (Ar)1 GF(2n) and an element Ar1 GF(2nm) also requires only m multiplications in GF(2n) and no reduction modulo polynomial P(x).
Fan 
The simplest case for the extension field of degree m = 2 was discussed in Kasahara 
Many research articles have already focused on VLSI architectures for fast implementations of arithmetic operations: multiplication, inversion and exponentiation.
Current approaches are combinations of structure of composite extension finite fields and ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 76 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- hardware architectures: bit parallel arithmetic in subfield and serial processing for extension field arithmetic.
This is called the parallel-serial (hybrid) approach.
This could have very fast implementations.
Refer to Paar 
e. Current issues on elliptic curves over composite extension finite fields Consider a non-supersingular elliptic curve over a composite extension finite field GF(2nm) of the equation: E: y2 + xy = x3 + ax2 + b, where coefficients a and b are in the subfield GF(2n).
Then E is referred to as a "subfield elliptic curve".
Particularly, when n = 1, it is just a Koblitz curve or a binary anomalous curve (ABC).
In practice, we prefer the order #E to be prime or divisible by a small number.
Hence we should use GF(2nm) where n is equal to 1 or is small and m is a large prime.
Otherwise, the order #E(GF(2nm)) will have a considerably large factor #E(GF(2n)).
However, there are always concerns about using the elliptic curves over composite extension Galois fields in cryptography by world mathematicians.
Refer to MÃ¯Â¿Â½ller 
There is also current research mentioning general doubts about constructing elliptic curves with special coefficients (such as Koblitz curves and subfield elliptic curves) and/or over finite fields with special internal structure (such as composite extension finite fields).
Gallant, Lambert 
The idea is to partition the group P into equivalence classes using the Frobenius endomorphisms : E(GF(2m)) E(GF(2m)), by: (x, y) = (x2, y2).
We define the equivalence relation ~ by: P1 ~ P2 if and only if P1 = Ã¯Â¿Â½ l(P2), for some l such that 0 l m 1.
Assuming that (P) = (x, y) = Ã¯Â¿Â½(x, y), then the equivalent class of point P includes [P] = {P, P, 2P,..., m1P, P, P, 2P,..., m1P} and [O]
Therefore, the number of elements to be searched is reduced by a factor of 2m; hence the running time that is proportional to the square root of the size of the group, will be reduced by a factor of (2m)1/2.
Wiener 
The running time is also reduced by a factor of (2m)1/2.
4.C.5.
Representing points on an elliptic curve The coordinates x and y of any point (x, y) on an elliptic curve must satisfy the cubic relation.
Hence to represent an elliptic curve point, both coordinates are not required.
Therefore, we can save space in storage of such points.
There are a few methods developed to represent elliptic curve points.
The terminology of such methods is not agreed upon globally yet. a.
Compressing and recovering points on an elliptic curve When p 
The compressing and recovering employs the propert that: the coordinates of two points P and its (additive) inverse point (P) are: P = (x, y) and (P) = (x, y) = (x, p y).
Compressing: Consider a point P = (xP, yP) on E.
Then the compressed form of P consists of xP and the rightmost bit of yP, denoted by P, when yP is written in the binary ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 77 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- expansion form.
In other words, we have P yP (mod 2).
Two values y and (p y) always have the opposite rightmost bits.
Recovering: Given xP and P, we can recover point P or, in fact, yP.
First, we 3 compute the square root r of value ( x P + axP + b) (mod p).
If the rightmost bit of r is equal to P, then yP = r. Otherwise, let yP = p r.
When p = 2, E: y2 + xy = x3 + ax2 + b, a non-supersingular elliptic curve over a finite finite field GF(2m).
For any two points P = (x, y) and P = (x, y + x), the difference between two ratios of point coordinates (yx1) and (y + x) x1 = yx1 + 1 are only 1, i.e., the rightmost bit in binary expansion form.
Observe also that if x 0, we can write the elliptic curve equation in terms of (yx1): (yx1)2 + yx1 = x + a + bx2.
Compressing: The compressed form of a point P = (xP, yP) on E consists of xP and a bit P.
If xP = 0, let P = 0.
(Actually, we do not care nor use this bit).
If xP 0, let P be - the rightmost bit of ( y P x P1 ) .
Recovering: Given xP and P, we can recover yP as follows.
If xP = 0, let yP be the root of b. Particularly, using the identity b 2 = b, we have yP = b 2 .
(We ignore P, or just consider it a check bit).
If xP 0, we need to solve the equation r2 + r = - + bx P2 (mod p) for a root ro. Observe that the other root is (ro + 1).
We choose r = = ro + 1, such that the rightmost bit of r is equal to P.
Then compute yP = xPr.
Compact form for cyclic subgroup of an elliptic curve This form, originally proposed by Seroussi [S98] is applied only for nonsupersingular elliptic curves E: y2 + xy = x3 + ax2 + b, with b 0, over a binary finite field GF(2m).
In fact, it is applied only for a cyclic subgroup of the elliptic curve.
We can rewrite the equation as: z2 + z = x + a + bx 2 where z = y/x, assuming that x 0.
We have some observations.
Given x 0, the above equation of z has a solution if and only if we have Tr (x + a + bx 2) = 0.
Therefore, for any point P = (x, y) E, where its xcoordinate 0, we must have the identity: Tr(x + a + bx2) = 0.
Using the equality: Tr(a + b) = Tr(a) + Tr(b), it can be rewritten as: Tr(x + bx2) + Tr(a) = 0 or Tr(x + bx2) = Tr(a), since values of the trace function Tr(Ã¯Â¿Â½) is in F2.
The point P = (0, y) in fact has order 2.
If Q = (xQ, yQ) = 2P E, then xQ = x2 + bx2.
If P (0, y), then Q is not the point at infinity.
Using the equality on trace function: Tr(x) = Tr(x2) over finite field GF(2m), we can derive the following relations: Tr(xQ) = Tr(x2 + bx2) = Tr(x + bx2) = Tr(a), for any point P whose order is other than 2.
Seroussi used this fact to represent a point on an elliptic curve by "compact form" that needed only m bits, instead of (m + 1) bits as they did in the compressed form, discussed above.
In an elliptic curve cryptosystem, we should always consider points in a cyclic subgroup of large prime order n (hence n is odd).
Any point P = (x, y) in such subgroup cannot have order 2, and there always exists a point R such that P = 2R.
Indeed, we can write explicitly: P = (n + 1)Ã¯Â¿Â½P = 2R, where R = [(n +1)/2]Ã¯Â¿Â½P.
In other words, we always have Tr(xP) = Tr (a), for any point P = (x, y) (0, y) that is used in an elliptic curve cryptosystem.
That is, we can eliminate one bit from the x-coordinate of point P = (x, y) without ambiguity.
The position of this bit can be chosen depending on the basis of the finite fields.
square the bit xP + a ro or r b. m m -1 ______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 78 of 105 NAS Technical Report - NAS-03-012 August 2003 ---------------------------------------------------------------------- ---------------------------------------------------------- Combined with the compressed form, we can fill up the removed bit from x by the single bit representing y-coordinate.
Hence this form has exactly m bits to represent a point P = (x, y) in the cyclic subgroup mentioned.
Particularly, we will utilize the matrix implementation of trace function Tr(x) = T.xt, where xt is the transpose matrix of x = (x0, x1,..., xm1) GF(2m) and T is an m Ã¯Â¿Â½ m matrix that depends on the basis used to represent the finite field GF(2m) and is calculated in advance.
Then we will eliminate any i-th position bit of x where the corresponding bit T(i) = 1 in the matrix T.
For recovering, that bit will be determined uniquely to get the relation between x and a: Tr(x) = Tr(a).
This representation is proved to be optimal for points on non-supersingular elliptic curves over finite field GF(2m).
Recall that a non-supersingular elliptic curve has even order and more particularly, #E(GF(2m)) 2Tr(a) (mod 4).
That is, one can write #E(GF(2m)) = 2s, for some value s (or even #E(GF(2m)) = 4s, for the case Tr(a) = 0).
Therefore, the prime order n of the interested cyclic subgroup of the elliptic curve is at most Ã¯Â¿Â½ (or Ã¯Â¿Â½ when Tr(a) = 0) of the curve order #E(GF(2m)) that is at most (2m + 1 + 2.2m/2).
We can even drop the term 1 since the order must be even.
Hence If Tr(a) = 1, then n 2m1 + 2m/2 
Hence, an m-bit form can be sufficient to represent all points in the cyclic subgroup of the elliptic curve.
If Tr(a) = 0, then n 2m2 + 2(m/2)1 
Hence, an (m 1)-bit form is sufficient.
c.
Other discussions The compressing techniques just solve the simple problem of only 1-bit ambiguity of the y-coordinate.
When we use only the x-coordinate, it does not matter how one can determine its corresponding y-coordinate of point P or its inverse point (P).
If we need the y-coordinate, we still can use other conventions without having explicitly the extra bit, from the known facts on the coordinates of point P and point (P) as follows: y(P) = p yP for prime finite fields Fp, p 
One can define y to be the smaller/larger, odd/even or "positive/negative" (in sense of modulo p) of two values upon mutual agreement.
Another approach is to try to use values independent of points (or y-coordinates) such as y2 or yÃ¯Â¿Â½(x + y) in our algorithms.
But this approach could cost us more than 1 bit.
For discussions and algorithms in this approach, refer to Montgomery [M97], Demytko [D94]
Another option that could be employed is to use the full y-coordinate of a point and two bits to represent x-coordinate, since for a given y, there are possibly three values of x from the elliptic curve equation.
However, the security of an elliptic curve cryptosystem does not depend on the representation of a point in either a compressed, non-compressed or compact form.
4.C.6.
Half-point algorithms It is reasonable and practically necessary to find algorithms to compute the half of a point, i.e., (Ã¯Â¿Â½Ã¯Â¿Â½P) of a given point P on an elliptic curve.
In other words, we need to solve the following problem: Given a point P, find another point Q on the same elliptic curve such that 2Q = P.
______________________________________________________________________ __________________ A Survey of Elliptic Curve Cryptosystems Part I: Introductory 10/27/2003 Page 79 of 105 NAS Technical Report - NAS-03-012 Au
